{-
Note:  Only position the comment and end-comment markers in column 1, or else
the HAL/S interpreter's BNF displays will be inaccurate.

Copyright:  	Public Domain
Filename:   	HAL_S.cf
Purpose:    	LBNF description of the HAL/S language, in so far as compiler 
            	generation via the BNF Converter compiler-compiler-compiler is 
            	concerned.  This description requires the preprocessor's --full
            	command-line switch.
History:    	2022-11-19 RSB  Previously this file was autogenerated
                            	by the script bnf2lbnf.py from the files
                            	HAL-S.bnf and extraHAL-S.lbnf.  From
                            	this point onward, that will no longer
                            	be done, and this file should be 
                            	directly modified.
            	2022-11-20 RSB  Lots of debugging to fix shift/reduce,
                            	reduce/shift, reduce/reduce conflicts.
            	2022-11-21 RSB  Builds the compiler (including parser)
                            	without errors or warnings now.  But 
                            	some HAL/S files which formerly compiled
                            	no longer do.
        	2022-11-25 RSB	Altered various LBNF labels to ease analysis
        			of front-end results by the compiler back-end.
        	2022-11-30 RSB	Tried to account for bracketed variables in
        			assignments and expressions.
        	2022-12-01 RSB	Some labeling fixups to make manual 
        			interpretation of abstract syntax tree easier.
        	2022-12-02 RSB	Fixes related into forward declarations of 
        			functions.  Corrected some RTL function types.
        	2022-12-03 RSB 	Fixed a variety of problems related to code
        			sample 167-ASSORTEDIO.hal.
        	2022-12-05 RSB	Added '^' as an alternative to '¬'.  My guess 
        			is that in spite of what all the documentation
        			says, the former was probably always used rather
        			than the latter, so I may eventually get rid of
        			the latter choice altogether.
        	2022-12-06 RSB	New arith identifier token "a_..." added, and 
        			the existing "b_...", "c_...", and "s_..." 
        			tokens modified somewhat to accommodate changes
        			I want to introduced in the preprocessor for 
        			mangling of structure fields.
  		2022-12-09 RSB	Added <STRUCTURE STMT>, <DECLARE STMT>, and
  				<REPLACE STMT> to <COMPILE LIST>.  The first
  				is to allow the preprocessor to replace 
  				INCLUDE TEMPLATE compiler directives by 
  				STRUCTURE statements.  But all three allow me 
  				to use the parser (if I choose to do so) to 
  				parse strings that comprise any of those three 
  				types individually.  I think I may be able to 
  				exploit that in the preprocessor, where those 
  				types of statements (and possibly some other 
  				types) need special treatment that's really too
  				cumbersome to duplicate in the Python code of 
  				the preprocessor.  We'll see.
  		2022-12-10 RSB	Replaced the token definitions by ones that
  				are functionally the same (or actually, more
  				accurate), but are easier to understand and
  				print.
  		2022-12-15 RSB	Continued fixes. Note that a <COMPILATION>
  				is now intended to be any list of statements
  				whatsoever.  This is in preparation for 
  				implementing an interpreter, but also it helps
  				with some of the code samples that weren't
  				implemented as complete programs, functions,
  				or procedures, but merely as a collection of
  				statements.
  		2023-01-05 RSB	Plenty of fixes and tweaks since my last 
  				entry.  The only one I really want to comment
  				on is that the preprocessor now converts
  				¬ and ^ to ~, and ¢ to `, neither of which is
  				in the HAL/S character set but which are 7-bit
  				ASCII, so we no longer have to worry about these 
  				multiple alternatives, nor about any characters
  				not in 7-bit ASCII.

Originally derived from the BNF description of the HAL/S programming 
language, in Appendix G of the HAL/S Language specification
(https://www.ibiblio.org/apollo/Shuttle/
     HAL_S%20Language%20Specification%20Nov%202005.pdf#page=209),
and mostly duplicated in the program comments of SYNTHESI.xpl
(which is a module of the original HAL/S compiler HAL/S-FC).
However, while that original description was fine for loose
documentation of the syntax, it was not sufficiently bug-free and
complete for direct use in automation.  Thus this file contains
substantial revisions and additions.

For documentation purposes, it's possible to convert this file to a
printable BNF representation, using the following commands:

	bnfc --latex HAL_S.cf
	... manual tweaking of HAL_S.tex ...
	pdflatex HAL_S.tex
	
The resulting file, HAL_S.pdf is the printable BNF.  However, the intermediate
file (HAL_S.tex) needs to be manually edited (in my opinion) to considerably
improve the final pdf.  Here's the editing needed:

    1.	Globally replace "HAL_S" by "HAL/S".
    2.  Globally replace "literals are recognized by the regular expression" 
    	by "=".
    3.  Replace the line reading "\documentclass[a4paper,11pt]{article}" by 
    	the following two lines:
    		\documentclass[10pt]{article}
		\usepackage[letterpaper, margin=1in]{geometry}
    4.	Replace "\title{The Language HAL/S}" by
    		\title{The Language Preprocessed HAL/S}
-}

entrypoints COMPILATION ;
comment "/*" "*/" ;

token NeqToken (["~"] | {"NOT"}[" "]*) ["="] ;
token LeToken ((["~"] | {"NOT"}[" "]*) [">"]) | {"<="} ;
token GeToken ((["~"] | {"NOT"}[" "]*) ["<"]) | {">="} ;
token NoArgUserFuncIdentifierToken {"nf_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token BitIdentifierToken {"b_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token BitFunctionIdentifierToken {"bf_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token CharFunctionIdentifierToken {"cf_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token CharIdentifierToken {"c_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token StructIdentifierToken {"s_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token StructFunctionIdentifierToken {"sf_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token LabelToken {"l_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token EventToken {"e_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token ArithFieldToken {"a_"} letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token IdentifierToken letter ( ( letter | digit | {"_"} )* ( letter | digit ) )? ;
token StringToken ["'"] ( letter | digit | {"''"} | ["_+-]% $()[|*./&~=<>#@,;:{}!?\""] )* ["'"] ;
token TextToken ["\""] ( letter | digit | ["_+-]% $()[|*./&~=<>#@,;:{}!?'"] )* ["\""] ;
token LevelToken ( ["123456789"] | ["12"] digit | ["3"]["012"] ) ;
token NumberToken digit+ ;
token CompoundToken ( digit+ ( ["."] digit* )? | ["."] digit+ ) ( ["EBH"] ["-"]? digit+ )* ;

--------------------------------------------------------------------------

AAdeclareBody_declarationList . DECLARE_BODY ::= DECLARATION_LIST ;
ABdeclareBody_attributes_declarationList . DECLARE_BODY ::= ATTRIBUTES "," DECLARATION_LIST ;
AAattributes_arraySpec_typeAndMinorAttr . ATTRIBUTES ::= ARRAY_SPEC TYPE_AND_MINOR_ATTR ;
ABattributes_arraySpec . ATTRIBUTES ::= ARRAY_SPEC ;
ACattributes_typeAndMinorAttr . ATTRIBUTES ::= TYPE_AND_MINOR_ATTR ;
AAdeclaration_nameId . DECLARATION ::= NAME_ID ;
ABdeclaration_nameId_attributes . DECLARATION ::= NAME_ID ATTRIBUTES ;
ACdeclaration_labelToken . DECLARATION ::= LabelToken ;
ACdeclaration_labelToken_type_minorAttrList . DECLARATION ::= LabelToken TYPE_AND_MINOR_ATTR ;
ACdeclaration_labelToken_procedure_minorAttrList . DECLARATION ::= LabelToken "PROCEDURE" MINOR_ATTR_LIST ;
ADdeclaration_labelToken_procedure . DECLARATION ::= LabelToken "PROCEDURE" ;
ACdeclaration_labelToken_function_minorAttrList . DECLARATION ::= LabelToken "FUNCTION" TYPE_AND_MINOR_ATTR ;
ADdeclaration_labelToken_function_minorAttrList . DECLARATION ::= NoArgUserFuncIdentifierToken "FUNCTION" TYPE_AND_MINOR_ATTR ;
ADdeclaration_labelToken_function . DECLARATION ::= LabelToken "FUNCTION" ;
AEdeclaration_labelToken_function . DECLARATION ::= NoArgUserFuncIdentifierToken "FUNCTION" ;
AEdeclaration_eventToken_event . DECLARATION ::= EventToken "EVENT" ;
AFdeclaration_eventToken_event_minorAttrList . DECLARATION ::= EventToken "EVENT" MINOR_ATTR_LIST ;
AGdeclaration_eventToken . DECLARATION ::= EventToken ;
AHdeclaration_eventToken_minorAttrList . DECLARATION ::= EventToken MINOR_ATTR_LIST ;
AAarraySpec_arrayHead_literalExpOrStar . ARRAY_SPEC ::= ARRAY_HEAD LITERAL_EXP_OR_STAR ")" ;
ABarraySpec_function . ARRAY_SPEC ::= "FUNCTION" ;
ACarraySpec_procedure . ARRAY_SPEC ::= "PROCEDURE" ;
ADarraySpec_program . ARRAY_SPEC ::= "PROGRAM" ;
AEarraySpec_task . ARRAY_SPEC ::= "TASK" ;
AAtypeAndMinorAttr_typeSpec . TYPE_AND_MINOR_ATTR ::= TYPE_SPEC ;
ABtypeAndMinorAttr_typeSpec_minorAttrList . TYPE_AND_MINOR_ATTR ::= TYPE_SPEC MINOR_ATTR_LIST ;
ACtypeAndMinorAttr_minorAttrList . TYPE_AND_MINOR_ATTR ::= MINOR_ATTR_LIST ;
AAidentifier . IDENTIFIER ::= IdentifierToken ;
AAsQdQName_doublyQualNameHead_literalExpOrStar . SQ_DQ_NAME ::= DOUBLY_QUAL_NAME_HEAD LITERAL_EXP_OR_STAR ")" ;
ABsQdQName_arithConv . SQ_DQ_NAME ::= ARITH_CONV ;
AAdoublyQualNameHead_vector . DOUBLY_QUAL_NAME_HEAD ::= "VECTOR" "(" ;
ABdoublyQualNameHead_matrix_literalExpOrStar . DOUBLY_QUAL_NAME_HEAD ::= "MATRIX" "(" LITERAL_EXP_OR_STAR "," ;
AAarithConv_integer . ARITH_CONV ::= "INTEGER" ;
ABarithConv_scalar . ARITH_CONV ::= "SCALAR" ;
ACarithConv_vector . ARITH_CONV ::= "VECTOR" ;
ADarithConv_matrix . ARITH_CONV ::= "MATRIX" ;

AAdeclaration_list . DECLARATION_LIST ::= DECLARATION ;
ABdeclaration_list . DECLARATION_LIST ::= DCL_LIST_COMMA DECLARATION ;
AAnameId_identifier . NAME_ID ::= IDENTIFIER ;
ABnameId_identifier_name . NAME_ID ::= IDENTIFIER "NAME" ;
ACnameId_bitId . NAME_ID ::= BIT_ID ;
ADnameId_charId . NAME_ID ::= CHAR_ID ;
AEnameId_bitFunctionIdentifierToken . NAME_ID ::= BitFunctionIdentifierToken ;
AFnameId_charFunctionIdentifierToken . NAME_ID ::= CharFunctionIdentifierToken ;
AGnameId_structIdentifierToken . NAME_ID ::= StructIdentifierToken ;
AHnameId_structFunctionIdentifierToken . NAME_ID ::= StructFunctionIdentifierToken ;

--------------------------------------------------------------------------
-- Here are just the rules for ARITH_EXP, without reference to BIT_EXP,
-- CHAR_EXP, STRUCT_EXP, NAME_EXP, or SUBSCRIPT.  The reason that the
-- XXX_EXP's I've omitted may be needed is that they may be parameters
-- in call lists for functions that have numeric return values.
AAarithExpTerm . ARITH_EXP ::= TERM ;
ABarithExpPlusTerm . ARITH_EXP ::= PLUS TERM ;
ACarithMinusTerm . ARITH_EXP ::= MINUS TERM ;
ADarithExpArithExpPlusTerm . ARITH_EXP ::= ARITH_EXP PLUS TERM ;
AEarithExpArithExpMinusTerm . ARITH_EXP ::= ARITH_EXP MINUS TERM ;
AAtermNoDivide . TERM ::= PRODUCT ;
ABtermDivide . TERM ::= PRODUCT "/" TERM ;
AAplus . PLUS ::= "+" ;
AAminus . MINUS ::= "-" ;
AAproductSingle . PRODUCT ::= FACTOR ;
ABproductCross . PRODUCT ::= FACTOR "*" PRODUCT ;
ACproductDot . PRODUCT ::= FACTOR "." PRODUCT ;
ADproductMultiplication . PRODUCT ::= FACTOR PRODUCT ;
AAfactor . FACTOR ::= PRIMARY ;
ABfactorExponentiation . FACTOR ::= PRIMARY EXPONENTIATION FACTOR ;
ABfactorTranspose . FACTOR ::= PRIMARY "**T" ;
AAexponentiation . EXPONENTIATION ::= "**" ;
AAprimary . PRIMARY ::= ARITH_VAR ;
AAarith_var . ARITH_VAR ::= ARITH_ID ;
ADprimary . PRIMARY ::= PRE_PRIMARY ;
AApre_primary . PRE_PRIMARY ::= "(" ARITH_EXP ")" ;
ABpre_primary . PRE_PRIMARY ::= NUMBER ;
ACpre_primary . PRE_PRIMARY ::= COMPOUND_NUMBER ;
AAnumber . NUMBER ::= SIMPLE_NUMBER ;
ABnumber . NUMBER ::= LEVEL ;
ZZlevel . LEVEL ::= LevelToken ;
CLcompound_number . COMPOUND_NUMBER ::= CompoundToken ;
CKsimple_number . SIMPLE_NUMBER ::= NumberToken ;
ABprimary . PRIMARY ::= MODIFIED_ARITH_FUNC ;
AAmodified_arith_func . MODIFIED_ARITH_FUNC ::= NO_ARG_ARITH_FUNC ;
ADprePrimaryRtlFunction . PRE_PRIMARY ::= ARITH_FUNC "(" CALL_LIST ")" ;
ADprePrimaryTypeof . PRE_PRIMARY ::= "typeof" "(" CALL_LIST ")";
ADprePrimaryTypeofv . PRE_PRIMARY ::= "typeofv" "(" CALL_LIST ")";
-- ADprePrimaryInitialized . PRE_PRIMARY ::= "initialized" "(" CALL_LIST ")";
ADprePrimaryRtlShaping . PRE_PRIMARY ::= SHAPING_HEAD ")" ;
ADprePrimaryRtlShapingStar . PRE_PRIMARY ::= SHAPING_HEAD "," "*" ")" ;
ADprePrimaryRtlShapingHeadInteger . SHAPING_HEAD ::= "INTEGER" "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadScalar . SHAPING_HEAD ::= "SCALAR" "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadVector . SHAPING_HEAD ::= "VECTOR" "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadMatrix . SHAPING_HEAD ::= "MATRIX" "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadIntegerSubscript . SHAPING_HEAD ::= "INTEGER" SUBSCRIPT "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadScalarSubscript . SHAPING_HEAD ::= "SCALAR" SUBSCRIPT "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadVectorSubscript . SHAPING_HEAD ::= "VECTOR" SUBSCRIPT "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadMatrixSubscript . SHAPING_HEAD ::= "MATRIX" SUBSCRIPT "(" REPEATED_CONSTANT ;
ADprePrimaryRtlShapingHeadRepeated . SHAPING_HEAD ::= SHAPING_HEAD "," REPEATED_CONSTANT ;
AEprePrimaryFunction . PRE_PRIMARY ::= LabelToken "(" CALL_LIST ")" ;
-- AAarith_func_head . ARITH_FUNC_HEAD ::= ARITH_FUNC ;
AAcall_list . CALL_LIST ::= LIST_EXP ;
ABcall_list . CALL_LIST ::= CALL_LIST "," LIST_EXP ;
AAlist_exp . LIST_EXP ::= EXPRESSION ;
ABlist_expRepeated . LIST_EXP ::= ARITH_EXP "#" EXPRESSION ;
--AClist_exp . LIST_EXP ::= STRUCTURE_ID ;
ADlist_exp . LIST_EXP ::= QUAL_STRUCT ;
AAexpression . EXPRESSION ::= ARITH_EXP ;
FGarith_id . ARITH_ID ::= IDENTIFIER ;
FHarith_id . ARITH_ID ::= ArithFieldToken ;
ZZnoArgumentUserFunction. NO_ARG_ARITH_FUNC ::= NoArgUserFuncIdentifierToken ;
ZZclocktime. NO_ARG_ARITH_FUNC ::= "CLOCKTIME" ;
ZZdate. NO_ARG_ARITH_FUNC ::= "DATE" ;
ZZerrgrp. NO_ARG_ARITH_FUNC ::= "ERRGRP" ;
ZZerrnum. NO_ARG_ARITH_FUNC ::= "ERRNUM" ;
ZZprio. NO_ARG_ARITH_FUNC ::= "PRIO" ;
ZZrandom. NO_ARG_ARITH_FUNC ::= "RANDOM" ;
ZZrandomg. NO_ARG_ARITH_FUNC ::= "RANDOMG" ;
ZZruntime. NO_ARG_ARITH_FUNC ::= "RUNTIME" ;
ZZnextime. ARITH_FUNC ::= "NEXTIME" ;
ZZabs. ARITH_FUNC ::= "ABS" ;
ZZceiling. ARITH_FUNC ::= "CEILING" ;
ZZdiv. ARITH_FUNC ::= "DIV" ;
ZZfloor. ARITH_FUNC ::= "FLOOR" ;
ZZmidval. ARITH_FUNC ::= "MIDVAL" ;
ZZmod. ARITH_FUNC ::= "MOD" ;
ZZodd. BIT_FUNC ::= "ODD" ;
ZZremainder. ARITH_FUNC ::= "REMAINDER" ;
ZZround. ARITH_FUNC ::= "ROUND" ;
ZZsign. ARITH_FUNC ::= "SIGN" ;
ZZsignum. ARITH_FUNC ::= "SIGNUM" ;
ZZtruncate. ARITH_FUNC ::= "TRUNCATE" ;
ZZarccos. ARITH_FUNC ::= "ARCCOS" ;
ZZarccosh. ARITH_FUNC ::= "ARCCOSH" ;
ZZarcsin. ARITH_FUNC ::= "ARCSIN" ;
ZZarcsinh. ARITH_FUNC ::= "ARCSINH" ;
ZZarctan2. ARITH_FUNC ::= "ARCTAN2" ;
ZZarctan. ARITH_FUNC ::= "ARCTAN" ;
ZZarctanh. ARITH_FUNC ::= "ARCTANH" ;
ZZcos. ARITH_FUNC ::= "COS" ;
ZZcosh. ARITH_FUNC ::= "COSH" ;
ZZexp. ARITH_FUNC ::= "EXP" ;
ZZlog. ARITH_FUNC ::= "LOG" ;
ZZsin. ARITH_FUNC ::= "SIN" ;
ZZsinh. ARITH_FUNC ::= "SINH" ;
ZZsqrt. ARITH_FUNC ::= "SQRT" ;
ZZtan. ARITH_FUNC ::= "TAN" ;
ZZtanh. ARITH_FUNC ::= "TANH" ;
ZZshl. ARITH_FUNC ::= "SHL" ;
ZZshr. ARITH_FUNC ::= "SHR" ;
ZZabval. ARITH_FUNC ::= "ABVAL" ;
ZZdet. ARITH_FUNC ::= "DET" ;
ZZtrace. ARITH_FUNC ::= "TRACE" ;
ZZunit. ARITH_FUNC ::= "UNIT" ;
--ZZmatrix. ARITH_FUNC ::= "MATRIX" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for SUBSCRIPT.
ACarith_var . ARITH_VAR ::= ARITH_ID SUBSCRIPT ;

AAarithVarBracketed . ARITH_VAR ::= "[" ARITH_ID "]" ;
ABarithVarBracketed . ARITH_VAR ::= "[" ARITH_ID "]" SUBSCRIPT ;
AAarithVarBraced . ARITH_VAR ::= "{" QUAL_STRUCT "}" ;
ABarithVarBraced . ARITH_VAR ::= "{" QUAL_STRUCT "}" SUBSCRIPT ;

ACmodified_arith_func . MODIFIED_ARITH_FUNC ::= NO_ARG_ARITH_FUNC SUBSCRIPT ;
AAsubscript . SUBSCRIPT ::= SUB_HEAD ")" ;
ABsubscript . SUBSCRIPT ::= QUALIFIER ;
ACsubscript . SUBSCRIPT ::= "$" NUMBER ;
ADsubscript . SUBSCRIPT ::= "$" ARITH_VAR ;
AAqualifier . QUALIFIER ::= "$" "(" "@" PREC_SPEC ")" ;
ABqualifier . QUALIFIER ::= "$" "(" SCALE_HEAD ARITH_EXP ")" ;
ACqualifier . QUALIFIER ::= "$" "(" "@" PREC_SPEC "," SCALE_HEAD ARITH_EXP ")" ;
ADqualifier . QUALIFIER ::= "$" "(" "@" RADIX ")" ;
AAscale_head . SCALE_HEAD ::= "@" ;
ABscale_head . SCALE_HEAD ::= "@" "@" ;
AAprecSpecSingle . PREC_SPEC ::= "SINGLE" ;
ABprecSpecDouble . PREC_SPEC ::= "DOUBLE" ;
AAsubStartGroup . SUB_START ::= "$" "(" ;
ABsubStartPrecSpec . SUB_START ::= "$" "(" "@" PREC_SPEC "," ;
ACsubStartSemicolon . SUB_START ::= SUB_HEAD ";" ;
ADsubStartColon . SUB_START ::= SUB_HEAD ":" ;
AEsubStartComma . SUB_START ::= SUB_HEAD "," ;
AAsub_head . SUB_HEAD ::= SUB_START ;
ABsub_head . SUB_HEAD ::= SUB_START SUB ;
AAsub . SUB ::= SUB_EXP ;
ABsubStar . SUB ::= "*" ;
ACsubExp . SUB ::= SUB_RUN_HEAD SUB_EXP ;
ADsubAt . SUB ::= ARITH_EXP "AT" SUB_EXP ;
AAsubRunHeadTo . SUB_RUN_HEAD ::= SUB_EXP "TO" ;
AAsub_exp . SUB_EXP ::= ARITH_EXP ;
ABsub_exp . SUB_EXP ::= POUND_EXPRESSION ;
AApound_expression . POUND_EXPRESSION ::= "#" ;
ABpound_expressionPlusTerm . POUND_EXPRESSION ::= POUND_EXPRESSION PLUS TERM ;
ACpound_expressionMinusTerm . POUND_EXPRESSION ::= POUND_EXPRESSION MINUS TERM ;
-- ABarith_func_head . ARITH_FUNC_HEAD ::= ARITH_CONV SUBSCRIPT ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for BIT_EXP.
ABexpression . EXPRESSION ::= BIT_EXP ;
AAbitExpFactor . BIT_EXP ::= BIT_FACTOR ;
ABbitExpOR . BIT_EXP ::= BIT_EXP OR BIT_FACTOR ;
AAbitFactor . BIT_FACTOR ::= BIT_CAT ;
ABbitFactorAnd . BIT_FACTOR ::= BIT_FACTOR AND BIT_CAT ;
AAbitCatPrim . BIT_CAT ::= BIT_PRIM ;
ABbitCatCat . BIT_CAT ::= BIT_CAT CAT BIT_PRIM ;
ACbitCatNotPrim . BIT_CAT ::= NOT BIT_PRIM ;
ADbitCatNotCat . BIT_CAT ::= BIT_CAT CAT NOT BIT_PRIM ;
AAOR . OR ::= CHAR_VERTICAL_BAR ;
ABOR . OR ::= "OR" ;
CFchar_vertical_bar . CHAR_VERTICAL_BAR ::= "|" ;
AAAND . AND ::= "&" ;
ABAND . AND ::= "AND" ;
AAbitPrimBitVar . BIT_PRIM ::= BIT_VAR ;
ABbitPrimLabelVar . BIT_PRIM ::= LABEL_VAR ;
ACbitPrimEventVar . BIT_PRIM ::= EVENT_VAR ;
ADbitBitConst . BIT_PRIM ::= BIT_CONST ;
AEbitPrimBitExp . BIT_PRIM ::= "(" BIT_EXP ")" ;
AHbitPrimSubbit . BIT_PRIM ::= SUBBIT_HEAD EXPRESSION ")" ;
AIbitPrimFunc . BIT_PRIM ::= BIT_FUNC_HEAD "(" CALL_LIST ")" ;
AIbitPrimInitialized . BIT_PRIM ::= "initialized" "(" CALL_LIST ")";
AAbitPrimBitVarBracketed . BIT_PRIM ::= "[" BIT_VAR "]" ;
ABbitPrimBitVarBracketed . BIT_PRIM ::= "[" BIT_VAR "]" SUBSCRIPT ;
AAbitPrimBitVarBraced . BIT_PRIM ::= "{" BIT_VAR "}" ;
ABbitPrimBitVarBraced . BIT_PRIM ::= "{" BIT_VAR "}" SUBSCRIPT ;
AAcat . CAT ::= "||" ;
ABcat . CAT ::= "CAT" ;
ABNOT . NOT ::= "NOT" ;
ADNOT . NOT ::= "~" ;
AAbit_var . BIT_VAR ::= BIT_ID ;
ACbit_var . BIT_VAR ::= BIT_ID SUBSCRIPT ;
AAlabel_var . LABEL_VAR ::= LABEL ;
ABlabel_var . LABEL_VAR ::= LABEL SUBSCRIPT ;
AAevent_var . EVENT_VAR ::= EVENT ;
ACevent_var . EVENT_VAR ::= EVENT SUBSCRIPT ;
AAbit_const_head . BIT_CONST_HEAD ::= RADIX ;
ABbit_const_head . BIT_CONST_HEAD ::= RADIX "(" NUMBER ")" ;
AAbitConstString . BIT_CONST ::= BIT_CONST_HEAD CHAR_STRING ;
ABbitConstTrue . BIT_CONST ::= "TRUE" ;
ACbitConstFalse . BIT_CONST ::= "FALSE" ;
ADbitConstOn . BIT_CONST ::= "ON" ;
AEbitConstOff . BIT_CONST ::= "OFF" ;
AAradixHEX . RADIX ::= "HEX" ;
ABradixOCT . RADIX ::= "OCT" ;
ACradixBIN . RADIX ::= "BIN" ;
ADradixDEC . RADIX ::= "DEC" ;
FPchar_string . CHAR_STRING ::= StringToken ;
AAsubbit_head . SUBBIT_HEAD ::= SUBBIT_KEY "(" ;
ABsubbit_head . SUBBIT_HEAD ::= SUBBIT_KEY SUBSCRIPT "(" ;
AAsubbit_key . SUBBIT_KEY ::= "SUBBIT" ;
AAbit_func_head . BIT_FUNC_HEAD ::= BIT_FUNC ;
ABbit_func_head . BIT_FUNC_HEAD ::= "BIT" ;
ACbit_func_head . BIT_FUNC_HEAD ::= "BIT" SUB_OR_QUALIFIER ;
FHbit_id . BIT_ID ::= BitIdentifierToken ;
FKlabel . LABEL ::= LabelToken ;
FLlabel . LABEL ::= BitFunctionIdentifierToken ;
FMlabel . LABEL ::= CharFunctionIdentifierToken ;
FNlabel . LABEL ::= StructFunctionIdentifierToken ;
ZZxor. BIT_FUNC ::= "XOR" ;
ZZuserBitFunction. BIT_FUNC ::= BitFunctionIdentifierToken ;
FLevent . EVENT ::= EventToken ;
AAsub_or_qualifier . SUB_OR_QUALIFIER ::= SUBSCRIPT ;
ABsub_or_qualifier . SUB_OR_QUALIFIER ::= BIT_QUALIFIER ;
AAbit_qualifier . BIT_QUALIFIER ::= "<" "$" "(" "@" RADIX ")" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for CHAR_EXP.
ACexpression . EXPRESSION ::= CHAR_EXP ;
AAcharExpPrim . CHAR_EXP ::= CHAR_PRIM ;
ABcharExpCat . CHAR_EXP ::= CHAR_EXP CAT CHAR_PRIM ;
ACcharExpCat . CHAR_EXP ::= CHAR_EXP CAT ARITH_EXP ;
ADcharExpCat . CHAR_EXP ::= ARITH_EXP CAT ARITH_EXP ;
AEcharExpCat . CHAR_EXP ::= ARITH_EXP CAT CHAR_PRIM ;
AAchar_prim . CHAR_PRIM ::= CHAR_VAR ;
ABchar_prim . CHAR_PRIM ::= CHAR_CONST ;
AEchar_prim . CHAR_PRIM ::= CHAR_FUNC_HEAD "(" CALL_LIST ")" ;
AFchar_prim . CHAR_PRIM ::= "(" CHAR_EXP ")" ;
AAchar_func_head . CHAR_FUNC_HEAD ::= CHAR_FUNC ;
ABchar_func_head . CHAR_FUNC_HEAD ::= "CHARACTER" SUB_OR_QUALIFIER ;
AAchar_var . CHAR_VAR ::= CHAR_ID ;
ACchar_var . CHAR_VAR ::= CHAR_ID SUBSCRIPT ;
AAchar_const . CHAR_CONST ::= CHAR_STRING ;
ABchar_const . CHAR_CONST ::= "CHAR" "(" NUMBER ")" CHAR_STRING ;
ZZindex. ARITH_FUNC ::= "INDEX" ;
ZZlength. ARITH_FUNC ::= "LENGTH" ;
ZZljust. CHAR_FUNC ::= "LJUST" ;
ZZrjust. CHAR_FUNC ::= "RJUST" ;
ZZtrim. CHAR_FUNC ::= "TRIM" ;
ZZuserCharFunction . CHAR_FUNC ::= CharFunctionIdentifierToken ;
FIchar_id . CHAR_ID ::= CharIdentifierToken ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for NAME_EXP.
AEexpression . EXPRESSION ::= NAME_EXP ;
AAnameExpKeyVar . NAME_EXP ::= NAME_KEY "(" NAME_VAR ")" ;
ABnameExpNull . NAME_EXP ::= "NULL" ;
ACnameExpKeyNull . NAME_EXP ::= NAME_KEY "(" "NULL" ")" ;
AAname_key . NAME_KEY ::= "NAME" ;
AAname_var . NAME_VAR ::= VARIABLE ;
ACname_var . NAME_VAR ::= MODIFIED_ARITH_FUNC ;
AAvariable . VARIABLE ::= ARITH_VAR ;
ACvariable . VARIABLE ::= BIT_VAR ;
AEvariable . VARIABLE ::= SUBBIT_HEAD VARIABLE ")" ;
AFvariable . VARIABLE ::= CHAR_VAR ;
AGvariable . VARIABLE ::= NAME_KEY "(" NAME_VAR ")" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for STRUCTURE_EXP and QUAL_STRUCT.
-- I believe this completes all rules for EXPRESSION.
ADexpression . EXPRESSION ::= STRUCTURE_EXP ;
AAstructure_exp . STRUCTURE_EXP ::= STRUCTURE_VAR ;
ADstructure_exp . STRUCTURE_EXP ::= STRUCT_FUNC_HEAD "(" CALL_LIST ")" ;
AAstruct_func_head . STRUCT_FUNC_HEAD ::= STRUCT_FUNC ;
AAstructure_var . STRUCTURE_VAR ::= QUAL_STRUCT SUBSCRIPT ;
ZZinverse. ARITH_FUNC ::= "INVERSE" ;
ZZtranspose. ARITH_FUNC ::= "TRANSPOSE" ;
ZZuserStructFunc . STRUCT_FUNC ::= StructFunctionIdentifierToken ;
ZZprod. ARITH_FUNC ::= "PROD" ;
ZZsum. ARITH_FUNC ::= "SUM" ;
ZZsize. ARITH_FUNC ::= "SIZE" ;
ZZmax. ARITH_FUNC ::= "MAX" ;
ZZmin. ARITH_FUNC ::= "MIN" ;
AAqual_struct . QUAL_STRUCT ::= STRUCTURE_ID ;
ABqual_struct . QUAL_STRUCT ::= QUAL_STRUCT "." STRUCTURE_ID ;
FJstructure_id . STRUCTURE_ID ::= StructIdentifierToken ;
AClabel_var . LABEL_VAR ::= QUAL_STRUCT "." LABEL ;
ADlabel_var . LABEL_VAR ::= QUAL_STRUCT "." LABEL SUBSCRIPT ;
ABbit_var . BIT_VAR ::= QUAL_STRUCT "." BIT_ID ;
ADbit_var . BIT_VAR ::= QUAL_STRUCT "." BIT_ID SUBSCRIPT ;
ABchar_var . CHAR_VAR ::= QUAL_STRUCT "." CHAR_ID ;
ADchar_var . CHAR_VAR ::= QUAL_STRUCT "." CHAR_ID SUBSCRIPT ;
ABevent_var . EVENT_VAR ::= QUAL_STRUCT "." EVENT ;
ADevent_var . EVENT_VAR ::= QUAL_STRUCT "." EVENT SUBSCRIPT ;
ADmodified_arith_func . MODIFIED_ARITH_FUNC ::= QUAL_STRUCT "." NO_ARG_ARITH_FUNC ;
AEmodified_arith_func . MODIFIED_ARITH_FUNC ::= QUAL_STRUCT "." NO_ARG_ARITH_FUNC SUBSCRIPT ;
ABarith_var . ARITH_VAR ::= QUAL_STRUCT "." ARITH_ID ;
ADarith_var . ARITH_VAR ::= QUAL_STRUCT "."  ARITH_ID SUBSCRIPT ;
ADvariable . VARIABLE ::= EVENT_VAR ;
ABvariable . VARIABLE ::= STRUCTURE_VAR ;
--AHvariable . VARIABLE ::= StructIdentifierToken ;
ABname_var . NAME_VAR ::= LABEL_VAR ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for ASSIGNMENT.  Well, that's 
-- easy!
AAassignment . ASSIGNMENT ::= VARIABLE EQUALS EXPRESSION ;
ABassignment . ASSIGNMENT ::= VARIABLE "," ASSIGNMENT ;
ACassignment . ASSIGNMENT ::= QUAL_STRUCT EQUALS EXPRESSION ;
ADassignment . ASSIGNMENT ::= QUAL_STRUCT "," ASSIGNMENT ;
AAequals . EQUALS ::= "=" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for IF_STATEMENT. 
AAstatement . STATEMENT ::= BASIC_STATEMENT ;
ABstatement . STATEMENT ::= OTHER_STATEMENT ;
ABbasicStatementAssignment . BASIC_STATEMENT ::= ASSIGNMENT ";" ;
ABotherStatementIf . OTHER_STATEMENT ::= IF_STATEMENT ;
AAifStatement . IF_STATEMENT ::= IF_CLAUSE STATEMENT ;
ABifThenElseStatement . IF_STATEMENT ::= TRUE_PART STATEMENT ;
AAifClauseRelationalExp . IF_CLAUSE ::= IF RELATIONAL_EXP THEN ;
ABifClauseBitExp . IF_CLAUSE ::= IF BIT_EXP THEN ;
AAtrue_part . TRUE_PART ::= IF_CLAUSE BASIC_STATEMENT "ELSE" ;
AAif . IF ::= "IF" ;
AAthen . THEN ::= "THEN" ;
AArelational_exp . RELATIONAL_EXP ::= RELATIONAL_FACTOR ;
ABrelational_expOR . RELATIONAL_EXP ::= RELATIONAL_EXP OR RELATIONAL_FACTOR ;
AArelational_factor . RELATIONAL_FACTOR ::= REL_PRIM ;
ABrelational_factorAND . RELATIONAL_FACTOR ::= RELATIONAL_FACTOR AND REL_PRIM ;
-- The following two lines originally had "1" RELATIONAL_EXP rather than just
-- RELATIONAL_EXP on the right.  Both the language specification and
-- the comments in SYNTHESI agree.  I find no explanation in any documentation
-- or code accessible to me as to what this may mean, and the "1" causes the
-- parser no end of trouble.  Besides, it's ambiguous:  What if the 
-- RELATIONAL_EXP were "X > 1".  Then having the "1" here would be 
-- indistinguishable from "1 X > 1", which multiplies 1 and X.  For now, I'm
-- just eliminating the "1".
AArel_prim . REL_PRIM ::= "(" RELATIONAL_EXP ")" ;
ABrel_prim . REL_PRIM ::= NOT "(" RELATIONAL_EXP ")" ;
ACrel_prim . REL_PRIM ::= COMPARISON ;
{-
AAcomparison . COMPARISON ::= ARITH_EXP RELATIONAL_OP ARITH_EXP ;
ABcomparison . COMPARISON ::= CHAR_EXP RELATIONAL_OP CHAR_EXP ;
ACcomparison . COMPARISON ::= BIT_CAT RELATIONAL_OP BIT_CAT ;
ADcomparison . COMPARISON ::= STRUCTURE_EXP RELATIONAL_OP STRUCTURE_EXP ;
AEcomparison . COMPARISON ::= NAME_EXP RELATIONAL_OP NAME_EXP ;
AArelationalOpEQ . RELATIONAL_OP ::= EQUALS ;
ABrelationalOpNEQ . RELATIONAL_OP ::= NeqToken ;
ACrelationalOpLT . RELATIONAL_OP ::= "<" ;
ADrelationalOpGT . RELATIONAL_OP ::= ">" ;
AErelationalOpLE . RELATIONAL_OP ::= LeToken ;
AFrelationalOpGE . RELATIONAL_OP ::= GeToken ;
-}
AAcomparisonEQ . COMPARISON ::= ARITH_EXP EQUALS ARITH_EXP ;
ABcomparisonEQ . COMPARISON ::= CHAR_EXP EQUALS CHAR_EXP ;
ACcomparisonEQ . COMPARISON ::= BIT_CAT EQUALS BIT_CAT ;
ADcomparisonEQ . COMPARISON ::= STRUCTURE_EXP EQUALS STRUCTURE_EXP ;
AEcomparisonEQ . COMPARISON ::= NAME_EXP EQUALS NAME_EXP ;
AAcomparisonNEQ . COMPARISON ::= ARITH_EXP NeqToken ARITH_EXP ;
ABcomparisonNEQ . COMPARISON ::= CHAR_EXP NeqToken CHAR_EXP ;
ACcomparisonNEQ . COMPARISON ::= BIT_CAT NeqToken BIT_CAT ;
ADcomparisonNEQ . COMPARISON ::= STRUCTURE_EXP NeqToken STRUCTURE_EXP ;
AEcomparisonNEQ . COMPARISON ::= NAME_EXP NeqToken NAME_EXP ;
AAcomparisonLT . COMPARISON ::= ARITH_EXP "<" ARITH_EXP ;
ABcomparisonLT . COMPARISON ::= CHAR_EXP "<" CHAR_EXP ;
ACcomparisonLT . COMPARISON ::= BIT_CAT "<" BIT_CAT ;
ADcomparisonLT . COMPARISON ::= STRUCTURE_EXP "<" STRUCTURE_EXP ;
AEcomparisonLT . COMPARISON ::= NAME_EXP "<" NAME_EXP ;
AAcomparisonGT . COMPARISON ::= ARITH_EXP ">" ARITH_EXP ;
ABcomparisonGT . COMPARISON ::= CHAR_EXP ">" CHAR_EXP ;
ACcomparisonGT . COMPARISON ::= BIT_CAT ">" BIT_CAT ;
ADcomparisonGT . COMPARISON ::= STRUCTURE_EXP ">" STRUCTURE_EXP ;
AEcomparisonGT . COMPARISON ::= NAME_EXP ">" NAME_EXP ;
AAcomparisonLE . COMPARISON ::= ARITH_EXP LeToken ARITH_EXP ;
ABcomparisonLE . COMPARISON ::= CHAR_EXP LeToken CHAR_EXP ;
ACcomparisonLE. COMPARISON ::= BIT_CAT LeToken BIT_CAT ;
ADcomparisonLE . COMPARISON ::= STRUCTURE_EXP LeToken STRUCTURE_EXP ;
AEcomparisonLE. COMPARISON ::= NAME_EXP LeToken NAME_EXP ;
AAcomparisonGE . COMPARISON ::= ARITH_EXP GeToken ARITH_EXP ;
ABcomparisonGE . COMPARISON ::= CHAR_EXP GeToken CHAR_EXP ;
ACcomparisonGE . COMPARISON ::= BIT_CAT GeToken BIT_CAT ;
ADcomparisonGE . COMPARISON ::= STRUCTURE_EXP GeToken STRUCTURE_EXP ;
AEcomparisonGE . COMPARISON ::= NAME_EXP GeToken NAME_EXP ;

--------------------------------------------------------------------------
-- Additional rules for more types of STATEMENTs, except BLOCKs. 
AAotherStatementOn . OTHER_STATEMENT ::= ON_PHRASE STATEMENT ;
ACother_statement . OTHER_STATEMENT ::= LABEL_DEFINITION OTHER_STATEMENT ;
AAany_statement . ANY_STATEMENT ::= STATEMENT ;
AAbasic_statement . BASIC_STATEMENT ::= LABEL_DEFINITION BASIC_STATEMENT ;
ACbasicStatementExit . BASIC_STATEMENT ::= "EXIT" ";" ;
ADbasicStatementExit . BASIC_STATEMENT ::= "EXIT" LABEL ";" ;
AEbasicStatementRepeat . BASIC_STATEMENT ::= "REPEAT" ";" ;
AFbasicStatementRepeat . BASIC_STATEMENT ::= "REPEAT" LABEL ";" ;
AGbasicStatementGoTo . BASIC_STATEMENT ::= "GO" "TO" LABEL ";" ;
AHbasicStatementEmpty . BASIC_STATEMENT ::= ";" ;
AIbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY ";" ;
AJbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY "(" CALL_LIST ")" ";" ;
AKbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY ASSIGN "(" CALL_ASSIGN_LIST ")" ";" ;
ALbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY "(" CALL_LIST ")" ASSIGN "(" CALL_ASSIGN_LIST ")" ";" ;
AMbasicStatementReturn . BASIC_STATEMENT ::= "RETURN" ";" ;
ANbasicStatementReturn . BASIC_STATEMENT ::= "RETURN" EXPRESSION ";" ;


--AObasicStatementDo . BASIC_STATEMENT ::= DO_GROUP_HEAD_PURE ENDING ";" ;
--APdoGroupHeadPure . DO_GROUP_HEAD_PURE ::= DO_GROUP_HEAD ;
AObasicStatementDo . BASIC_STATEMENT ::= DO_GROUP_HEAD ENDING ";" ;

APbasicStatementReadKey . BASIC_STATEMENT ::= READ_KEY ";" ;
AQbasicStatementReadPhrase . BASIC_STATEMENT ::= READ_PHRASE ";" ;
ARbasicStatementWriteKey . BASIC_STATEMENT ::= WRITE_KEY ";" ;
ASbasicStatementWritePhrase . BASIC_STATEMENT ::= WRITE_PHRASE ";" ;
ATbasicStatementFileExp . BASIC_STATEMENT ::= FILE_EXP EQUALS EXPRESSION ";" ;
AUbasicStatementFileExp . BASIC_STATEMENT ::= VARIABLE EQUALS FILE_EXP ";" ;
AVbasicStatementFileExp . BASIC_STATEMENT ::= FILE_EXP EQUALS QUAL_STRUCT ";" ;
AVbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY "FOR" "DEPENDENT" ";" ;
AWbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY ARITH_EXP ";" ;
AXbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY "UNTIL" ARITH_EXP ";" ;
AYbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY "FOR" BIT_EXP ";" ;
AZbasicStatementTerminator . BASIC_STATEMENT ::= TERMINATOR ";" ;
BAbasicStatementTerminator . BASIC_STATEMENT ::= TERMINATOR TERMINATE_LIST ";" ;
BBbasicStatementUpdate . BASIC_STATEMENT ::= "UPDATE" "PRIORITY" "TO" ARITH_EXP ";" ;
BCbasicStatementUpdate . BASIC_STATEMENT ::= "UPDATE" "PRIORITY" LABEL_VAR "TO" ARITH_EXP ";" ;
BDbasicStatementSchedule . BASIC_STATEMENT ::= SCHEDULE_PHRASE ";" ;
BEbasicStatementSchedule . BASIC_STATEMENT ::= SCHEDULE_PHRASE SCHEDULE_CONTROL ";" ;
BFbasicStatementSignal . BASIC_STATEMENT ::= SIGNAL_CLAUSE ";" ;
BGbasicStatementSend . BASIC_STATEMENT ::= "SEND" "ERROR" SUBSCRIPT ";" ;
BHbasicStatementSend . BASIC_STATEMENT ::= "SEND" "ERROR" ";" ;
BHbasicStatementOn . BASIC_STATEMENT ::= ON_CLAUSE ";" ;
BIbasicStatementOnAndSignal . BASIC_STATEMENT ::= ON_CLAUSE "AND" SIGNAL_CLAUSE ";" ;
BJbasicStatementOff . BASIC_STATEMENT ::= "OFF" "ERROR" SUBSCRIPT ";" ;
BKbasicStatementOff . BASIC_STATEMENT ::= "OFF" "ERROR" ";" ;
BKbasicStatementPercentMacro . BASIC_STATEMENT ::= PERCENT_MACRO_NAME ";" ;
BLbasicStatementPercentMacro . BASIC_STATEMENT ::= PERCENT_MACRO_HEAD PERCENT_MACRO_ARG ")" ";" ;
AAon_phrase . ON_PHRASE ::= "ON" "ERROR" SUBSCRIPT ;
AAon_clause . ON_CLAUSE ::= "ON" "ERROR" SUBSCRIPT "SYSTEM" ;
ABon_clause . ON_CLAUSE ::= "ON" "ERROR" SUBSCRIPT "IGNORE" ;
ACon_phrase . ON_PHRASE ::= "ON" "ERROR" ;
ADon_clause . ON_CLAUSE ::= "ON" "ERROR" "SYSTEM" ;
AEon_clause . ON_CLAUSE ::= "ON" "ERROR" "IGNORE" ;
AAlabel_definition . LABEL_DEFINITION ::= LABEL ":" ;
AAcall_key . CALL_KEY ::= "CALL" LABEL_VAR ;
AAassign . ASSIGN ::= "ASSIGN" ;
AAcall_assign_list . CALL_ASSIGN_LIST ::= VARIABLE ;
ABcall_assign_list . CALL_ASSIGN_LIST ::= CALL_ASSIGN_LIST "," VARIABLE ;
ACcall_assign_list . CALL_ASSIGN_LIST ::= QUAL_STRUCT ;
ADcall_assign_list . CALL_ASSIGN_LIST ::= CALL_ASSIGN_LIST "," QUAL_STRUCT ;
AAdoGroupHead . DO_GROUP_HEAD ::= "DO" ";" ;
ABdoGroupHeadFor . DO_GROUP_HEAD ::= "DO" FOR_LIST ";" ;
ACdoGroupHeadForWhile . DO_GROUP_HEAD ::= "DO" FOR_LIST WHILE_CLAUSE ";" ;
ADdoGroupHeadWhile . DO_GROUP_HEAD ::= "DO" WHILE_CLAUSE ";" ;
AEdoGroupHeadCase . DO_GROUP_HEAD ::= "DO" "CASE" ARITH_EXP ";" ;
AFdoGroupHeadCaseElse . DO_GROUP_HEAD ::= CASE_ELSE STATEMENT ;
AGdoGroupHeadStatement . DO_GROUP_HEAD ::= DO_GROUP_HEAD ANY_STATEMENT ;
AHdoGroupHeadTemporaryStatement . DO_GROUP_HEAD ::= DO_GROUP_HEAD TEMPORARY_STMT ;
AAending . ENDING ::= "END" ;
ABending . ENDING ::= "END" LABEL ;
ACending . ENDING ::= LABEL_DEFINITION ENDING ;
AAread_key . READ_KEY ::= "READ" "(" NUMBER ")" ;
ABread_key . READ_KEY ::= "READALL" "(" NUMBER ")" ;
AAwrite_key . WRITE_KEY ::= "WRITE" "(" NUMBER ")" ;
AAread_phrase . READ_PHRASE ::= READ_KEY READ_ARG ;
ABread_phrase . READ_PHRASE ::= READ_PHRASE "," READ_ARG ;
AAwrite_phrase . WRITE_PHRASE ::= WRITE_KEY WRITE_ARG ;
ABwrite_phrase . WRITE_PHRASE ::= WRITE_PHRASE "," WRITE_ARG ;
AAread_arg . READ_ARG ::= VARIABLE ;
ABread_arg . READ_ARG ::= IO_CONTROL ;
AAwrite_arg . WRITE_ARG ::= EXPRESSION ;
ABwrite_arg . WRITE_ARG ::= IO_CONTROL ;
ACwrite_arg . WRITE_ARG ::= StructIdentifierToken ;
AAfile_exp . FILE_EXP ::= FILE_HEAD "," ARITH_EXP ")" ;
AAfile_head . FILE_HEAD ::= "FILE" "(" NUMBER ;
AAioControlSkip . IO_CONTROL ::= "SKIP" "(" ARITH_EXP ")" ;
ABioControlTab . IO_CONTROL ::= "TAB" "(" ARITH_EXP ")" ;
ACioControlColumn . IO_CONTROL ::= "COLUMN" "(" ARITH_EXP ")" ;
ADioControlLine . IO_CONTROL ::= "LINE" "(" ARITH_EXP ")" ;
AEioControlPage . IO_CONTROL ::= "PAGE" "(" ARITH_EXP ")" ;
AAwait_key . WAIT_KEY ::= "WAIT" ;
AAterminatorTerminate . TERMINATOR ::= "TERMINATE" ;
ABterminatorCancel . TERMINATOR ::= "CANCEL" ;
AAterminate_list . TERMINATE_LIST ::= LABEL_VAR ;
ABterminate_list . TERMINATE_LIST ::= TERMINATE_LIST "," LABEL_VAR ;
AAscheduleHeadLabel . SCHEDULE_HEAD ::= "SCHEDULE" LABEL_VAR ;
ABscheduleHeadAt . SCHEDULE_HEAD ::= SCHEDULE_HEAD "AT" ARITH_EXP ;
ACscheduleHeadIn . SCHEDULE_HEAD ::= SCHEDULE_HEAD "IN" ARITH_EXP ;
ADscheduleHeadOn . SCHEDULE_HEAD ::= SCHEDULE_HEAD "ON" BIT_EXP ;
AAschedule_phrase . SCHEDULE_PHRASE ::= SCHEDULE_HEAD ;
ABschedule_phrase . SCHEDULE_PHRASE ::= SCHEDULE_HEAD "PRIORITY" "(" ARITH_EXP ")" ;
ACschedule_phrase . SCHEDULE_PHRASE ::= SCHEDULE_PHRASE "DEPENDENT" ;
AAschedule_control . SCHEDULE_CONTROL ::= STOPPING ;
ABschedule_control . SCHEDULE_CONTROL ::= TIMING ;
ACschedule_control . SCHEDULE_CONTROL ::= TIMING STOPPING ;
AAtimingEvery . TIMING ::= REPEAT "EVERY" ARITH_EXP ;
ABtimingAfter . TIMING ::= REPEAT "AFTER" ARITH_EXP ;
ACtiming . TIMING ::= REPEAT ;
AArepeat . REPEAT ::= "," "REPEAT" ;
AAstopping . STOPPING ::= WHILE_KEY ARITH_EXP ;
ABstopping . STOPPING ::= WHILE_KEY BIT_EXP ;
AAsignal_clause . SIGNAL_CLAUSE ::= "SET" EVENT_VAR ;
ABsignal_clause . SIGNAL_CLAUSE ::= "RESET" EVENT_VAR ;
ACsignal_clause . SIGNAL_CLAUSE ::= "SIGNAL" EVENT_VAR ;
FNpercent_macro_name . PERCENT_MACRO_NAME ::= "%" IDENTIFIER ;
AApercent_macro_head . PERCENT_MACRO_HEAD ::= PERCENT_MACRO_NAME "(" ;
ABpercent_macro_head . PERCENT_MACRO_HEAD ::= PERCENT_MACRO_HEAD PERCENT_MACRO_ARG "," ;
AApercent_macro_arg . PERCENT_MACRO_ARG ::= NAME_VAR ;
ABpercent_macro_arg . PERCENT_MACRO_ARG ::= CONSTANT ;
AAcase_else . CASE_ELSE ::= "DO" "CASE" ARITH_EXP ";" "ELSE" ;
AAwhileKeyWhile . WHILE_KEY ::= "WHILE" ;
ABwhileKeyUntil . WHILE_KEY ::= "UNTIL" ;
AAwhile_clause . WHILE_CLAUSE ::= WHILE_KEY BIT_EXP ;
ABwhile_clause . WHILE_CLAUSE ::= WHILE_KEY RELATIONAL_EXP ;
AAfor_list . FOR_LIST ::= FOR_KEY ARITH_EXP ITERATION_CONTROL ;
ABfor_listDiscrete . FOR_LIST ::= FOR_KEY ITERATION_BODY ;
AAiteration_body . ITERATION_BODY ::= ARITH_EXP ;
ABiteration_body . ITERATION_BODY ::= ITERATION_BODY "," ARITH_EXP ;
AAiteration_controlTo . ITERATION_CONTROL ::= "TO" ARITH_EXP ;
ABiteration_controlToBy . ITERATION_CONTROL ::= "TO" ARITH_EXP "BY" ARITH_EXP ;
AAforKey . FOR_KEY ::= "FOR" ARITH_VAR EQUALS ;
ABforKeyTemporary . FOR_KEY ::= "FOR" "TEMPORARY" IDENTIFIER "=" ;
AAtemporary_stmt . TEMPORARY_STMT ::= "TEMPORARY" DECLARE_BODY ";" ;
AAconstant . CONSTANT ::= NUMBER ;
ABconstant . CONSTANT ::= COMPOUND_NUMBER ;
ACconstant . CONSTANT ::= BIT_CONST ;
ADconstant . CONSTANT ::= CHAR_CONST ;
AAarray_head . ARRAY_HEAD ::= "ARRAY" "(" ;
ABarray_head . ARRAY_HEAD ::= ARRAY_HEAD LITERAL_EXP_OR_STAR "," ;
AAminor_attr_list . MINOR_ATTR_LIST ::= MINOR_ATTRIBUTE ;
ABminor_attr_list . MINOR_ATTR_LIST ::= MINOR_ATTR_LIST MINOR_ATTRIBUTE ;
AAminorAttributeStatic . MINOR_ATTRIBUTE ::= "STATIC" ;
ABminorAttributeAutomatic . MINOR_ATTRIBUTE ::= "AUTOMATIC" ;
ACminorAttributeDense . MINOR_ATTRIBUTE ::= "DENSE" ;
ADminorAttributeAligned . MINOR_ATTRIBUTE ::= "ALIGNED" ;
AEminorAttributeAccess . MINOR_ATTRIBUTE ::= "ACCESS" ;
AFminorAttributeLock . MINOR_ATTRIBUTE ::= "LOCK" "(" LITERAL_EXP_OR_STAR ")" ;
AGminorAttributeRemote . MINOR_ATTRIBUTE ::= "REMOTE" ;
AHminorAttributeRigid . MINOR_ATTRIBUTE ::= "RIGID" ;
AIminorAttributeRepeatedConstant . MINOR_ATTRIBUTE ::= INIT_OR_CONST_HEAD REPEATED_CONSTANT ")" ;
-- AJminorAttributeRepeatedConstant . MINOR_ATTRIBUTE ::= INIT_OR_CONST_HEAD REPEATED_CONSTANT "," "*" ")" ;
AJminorAttributeStar . MINOR_ATTRIBUTE ::= INIT_OR_CONST_HEAD "*" ")" ;
AKminorAttributeLatched . MINOR_ATTRIBUTE ::= "LATCHED" ;
ALminorAttributeNonHal . MINOR_ATTRIBUTE ::= "NONHAL" "(" LEVEL ")" ;
AAinit_or_const_headInitial . INIT_OR_CONST_HEAD ::= "INITIAL" "(" ;
ABinit_or_const_headConstant . INIT_OR_CONST_HEAD ::= "CONSTANT" "(" ;
ACinit_or_const_headRepeatedConstant . INIT_OR_CONST_HEAD ::= INIT_OR_CONST_HEAD REPEATED_CONSTANT "," ;
AArepeated_constant . REPEATED_CONSTANT ::= EXPRESSION ;
ABrepeated_constantMark . REPEATED_CONSTANT ::= REPEAT_HEAD VARIABLE ;
ACrepeated_constantMark . REPEATED_CONSTANT ::= REPEAT_HEAD CONSTANT ;
ADrepeated_constantMark . REPEATED_CONSTANT ::= NESTED_REPEAT_HEAD REPEATED_CONSTANT ")" ;
AErepeated_constantMark . REPEATED_CONSTANT ::= REPEAT_HEAD ;
AArepeat_head . REPEAT_HEAD ::= ARITH_EXP "#" ;
AAnested_repeat_head . NESTED_REPEAT_HEAD ::= REPEAT_HEAD "(" ;
ABnested_repeat_head . NESTED_REPEAT_HEAD ::= NESTED_REPEAT_HEAD REPEATED_CONSTANT "," ;
AAdcl_list_comma . DCL_LIST_COMMA ::= DECLARATION_LIST "," ;
AAliteralExp . LITERAL_EXP_OR_STAR ::= ARITH_EXP ;
ABliteralStar . LITERAL_EXP_OR_STAR ::= "*" ;
AAtypeSpecStruct . TYPE_SPEC ::= STRUCT_SPEC ;
ABtypeSpecBit . TYPE_SPEC ::= BIT_SPEC ;
ACtypeSpecChar . TYPE_SPEC ::= CHAR_SPEC ;
ADtypeSpecArith . TYPE_SPEC ::= ARITH_SPEC ;
AEtypeSpecEvent . TYPE_SPEC ::= "EVENT" ;
AAbitSpecBoolean . BIT_SPEC ::= "BOOLEAN" ;
ABbitSpecBoolean . BIT_SPEC ::= "BIT" "(" LITERAL_EXP_OR_STAR ")" ;
AAchar_spec . CHAR_SPEC ::= "CHARACTER" "(" LITERAL_EXP_OR_STAR ")" ;
AAstruct_spec . STRUCT_SPEC ::= STRUCT_TEMPLATE STRUCT_SPEC_BODY ;
AAstruct_spec_body . STRUCT_SPEC_BODY ::= "-" "STRUCTURE" ;
ABstruct_spec_body . STRUCT_SPEC_BODY ::= STRUCT_SPEC_HEAD LITERAL_EXP_OR_STAR ")" ;
FMstruct_template . STRUCT_TEMPLATE ::= STRUCTURE_ID ;
AAstruct_spec_head . STRUCT_SPEC_HEAD ::= "-" "STRUCTURE" "(" ;
AAarith_spec . ARITH_SPEC ::= PREC_SPEC ;
ABarith_spec . ARITH_SPEC ::= SQ_DQ_NAME ;
ACarith_spec . ARITH_SPEC ::= SQ_DQ_NAME PREC_SPEC ;

--------------------------------------------------------------------------
-- Here are additional rules needed for top-level block types (like 
-- program, procedure, and function).
{-
AAcompilation . COMPILATION ::= COMPILE_LIST ;
AAcompile_list . COMPILE_LIST ::= TOP_LEVEL ;
ABcompile_list . COMPILE_LIST ::= COMPILE_LIST TOP_LEVEL ;
AAtopLevel . TOP_LEVEL ::= STRUCTURE_STMT ;
ABtopLevel . TOP_LEVEL ::= DECLARE_STATEMENT ;
ACtopLevel . TOP_LEVEL ::= REPLACE_STMT ";" ;
ADtopLevel . TOP_LEVEL ::= BLOCK_DEFINITION ;
AAcompile_list . COMPILE_LIST ::= ANY_STATEMENT ;
ABcompile_list . COMPILE_LIST ::= COMPILE_LIST ANY_STATEMENT ;
ACcompile_list . COMPILE_LIST ::= DECLARE_STATEMENT ;
ADcompile_list . COMPILE_LIST ::= COMPILE_LIST DECLARE_STATEMENT ;
AAcompile_list . COMPILE_LIST ::= ANY_STATEMENT ;
ABcompile_list . COMPILE_LIST ::= COMPILE_LIST ANY_STATEMENT ;
ACcompile_list . COMPILE_LIST ::= DECLARE_STATEMENT ;
ADcompile_list . COMPILE_LIST ::= COMPILE_LIST DECLARE_STATEMENT ;
-}
AAcompilation . COMPILATION ::= ANY_STATEMENT ;
ABcompilation . COMPILATION ::= COMPILATION ANY_STATEMENT ;
ACcompilation . COMPILATION ::= DECLARE_STATEMENT ;
ADcompilation . COMPILATION ::= COMPILATION DECLARE_STATEMENT ;
AEcompilation . COMPILATION ::= STRUCTURE_STMT ;
AFcompilation . COMPILATION ::= COMPILATION STRUCTURE_STMT ;
AGcompilation . COMPILATION ::= REPLACE_STMT ";" ;
AHcompilation . COMPILATION ::= COMPILATION REPLACE_STMT ";" ;
AZcompilationInitOrConst . COMPILATION ::= INIT_OR_CONST_HEAD EXPRESSION ")" ;
AAblock_definition . BLOCK_DEFINITION ::= BLOCK_STMT CLOSING ";" ;
ABblock_definition . BLOCK_DEFINITION ::= BLOCK_STMT BLOCK_BODY CLOSING ";" ;
AAblock_stmt . BLOCK_STMT ::= BLOCK_STMT_TOP ";" ;
AAblockTopAccess . BLOCK_STMT_TOP ::= BLOCK_STMT_TOP "ACCESS" ;
ABblockTopRigid . BLOCK_STMT_TOP ::= BLOCK_STMT_TOP "RIGID" ;
ACblockTopHead . BLOCK_STMT_TOP ::= BLOCK_STMT_HEAD ;
ADblockTopExclusive . BLOCK_STMT_TOP ::= BLOCK_STMT_HEAD "EXCLUSIVE" ;
AEblockTopReentrant . BLOCK_STMT_TOP ::= BLOCK_STMT_HEAD "REENTRANT" ;
AAblockHeadProgram . BLOCK_STMT_HEAD ::= LABEL_EXTERNAL "PROGRAM" ;
ABblockHeadCompool . BLOCK_STMT_HEAD ::= LABEL_EXTERNAL "COMPOOL" ;
ACblockHeadTask . BLOCK_STMT_HEAD ::= LABEL_DEFINITION "TASK" ;
ADblockHeadUpdate . BLOCK_STMT_HEAD ::= LABEL_DEFINITION "UPDATE" ;
AEblockHeadUpdate . BLOCK_STMT_HEAD ::= "UPDATE" ;
AFblockHeadFunction . BLOCK_STMT_HEAD ::= FUNCTION_NAME ;
AGblockHeadFunction . BLOCK_STMT_HEAD ::= FUNCTION_NAME FUNC_STMT_BODY ;
AHblockHeadProcedure . BLOCK_STMT_HEAD ::= PROCEDURE_NAME ;
AIblockHeadProcedure . BLOCK_STMT_HEAD ::= PROCEDURE_NAME PROC_STMT_BODY ;
AAlabel_external . LABEL_EXTERNAL ::= LABEL_DEFINITION ;
ABlabel_external . LABEL_EXTERNAL ::= LABEL_DEFINITION "EXTERNAL" ;
AAclosing . CLOSING ::= "CLOSE" ;
ABclosing . CLOSING ::= "CLOSE" LABEL ;
ADclosing . CLOSING ::= "CLOSE" NoArgUserFuncIdentifierToken ;
ACclosing . CLOSING ::= LABEL_DEFINITION CLOSING ;
ABblock_body . BLOCK_BODY ::= DECLARE_GROUP ;
ADblock_body . BLOCK_BODY ::= ANY_STATEMENT ;
ACblock_body . BLOCK_BODY ::= BLOCK_BODY ANY_STATEMENT ;
AAfunction_name . FUNCTION_NAME ::= LABEL_EXTERNAL "FUNCTION" ;
ABfunction_name . FUNCTION_NAME ::= NoArgUserFuncIdentifierToken ":" "FUNCTION" ;
ACfunction_name . FUNCTION_NAME ::= NoArgUserFuncIdentifierToken ":" "EXTERNAL" "FUNCTION" ;
AAprocedure_name . PROCEDURE_NAME ::= LABEL_EXTERNAL "PROCEDURE" ;
AAfunc_stmt_body . FUNC_STMT_BODY ::= PARAMETER_LIST ;
ABfunc_stmt_body . FUNC_STMT_BODY ::= TYPE_SPEC ;
ACfunc_stmt_body . FUNC_STMT_BODY ::= PARAMETER_LIST TYPE_SPEC ;
AAproc_stmt_body . PROC_STMT_BODY ::= PARAMETER_LIST ;
ABproc_stmt_body . PROC_STMT_BODY ::= ASSIGN_LIST ;
ACproc_stmt_body . PROC_STMT_BODY ::= PARAMETER_LIST ASSIGN_LIST ;
AAdeclare_group . DECLARE_GROUP ::= DECLARE_ELEMENT ;
ABdeclare_group . DECLARE_GROUP ::= DECLARE_GROUP DECLARE_ELEMENT ;
AAdeclareElementDeclare . DECLARE_ELEMENT ::= DECLARE_STATEMENT ;
ABdeclareElementReplace . DECLARE_ELEMENT ::= REPLACE_STMT ";" ;
ACdeclareElementStructure . DECLARE_ELEMENT ::= STRUCTURE_STMT ;
ADdeclareElementEquate . DECLARE_ELEMENT ::= "EQUATE" "EXTERNAL" IDENTIFIER "TO" VARIABLE ";" ;
AAparameter . PARAMETER ::= IdentifierToken ;
ABparameter . PARAMETER ::= BitIdentifierToken ;
ACparameter . PARAMETER ::= CharIdentifierToken ;
ADparameter . PARAMETER ::= StructIdentifierToken ;
AEparameter . PARAMETER ::= EventToken ;
AFparameter . PARAMETER ::= LabelToken ;
AAparameter_list . PARAMETER_LIST ::= PARAMETER_HEAD PARAMETER ")" ;
AAparameter_head . PARAMETER_HEAD ::= "(" ;
ABparameter_head . PARAMETER_HEAD ::= PARAMETER_HEAD PARAMETER "," ;
AAdeclare_statement . DECLARE_STATEMENT ::= "DECLARE" DECLARE_BODY ";" ;
AAassign_list . ASSIGN_LIST ::= ASSIGN PARAMETER_LIST ;
FQtext . TEXT ::= TextToken ;
AAreplace_stmt . REPLACE_STMT ::= "REPLACE" REPLACE_HEAD "BY" TEXT ;
AAreplace_head . REPLACE_HEAD ::= IDENTIFIER ;
ABreplace_head . REPLACE_HEAD ::= IDENTIFIER "(" ARG_LIST ")" ;
AAarg_list . ARG_LIST ::= IDENTIFIER ;
ABarg_list . ARG_LIST ::= ARG_LIST "," IDENTIFIER ;
AAstructure_stmt . STRUCTURE_STMT ::= "STRUCTURE" STRUCT_STMT_HEAD STRUCT_STMT_TAIL ;
AAstruct_stmt_head . STRUCT_STMT_HEAD ::= STRUCTURE_ID ":" LEVEL ;
ABstruct_stmt_head . STRUCT_STMT_HEAD ::= STRUCTURE_ID MINOR_ATTR_LIST ":" LEVEL ;
ACstruct_stmt_head . STRUCT_STMT_HEAD ::= STRUCT_STMT_HEAD DECLARATION "," LEVEL ;
AAstruct_stmt_tail . STRUCT_STMT_TAIL ::= DECLARATION ";" ;

--------------------------------------------------------------------------
-- Inline types (functions, procedures, ...).  I think that all of the 
-- rules relating to the parents of inline types in the original 
-- BNF were wrong.  In all cases, the inline definitions had been 
-- children of terms of expressions, whereas obviously they are types
-- of statements and not components of expressions.
AZstatement . STATEMENT ::= INLINE_DEFINITION ;
AAinline_definition . INLINE_DEFINITION ::= ARITH_INLINE ;
ABinline_definition . INLINE_DEFINITION ::= BIT_INLINE ;
ACinline_definition . INLINE_DEFINITION ::= CHAR_INLINE ;
ADinline_definition . INLINE_DEFINITION ::= STRUCTURE_EXP ;
-- Was PRIMARY rather rather than ARITH_INLINE.
ACprimary . ARITH_INLINE ::= ARITH_INLINE_DEF CLOSING ";" ;
AZprimary . ARITH_INLINE ::= ARITH_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAarith_inline_def . ARITH_INLINE_DEF ::= "FUNCTION" ARITH_SPEC ";" ;
ABarith_inline_def . ARITH_INLINE_DEF ::= "FUNCTION" ";" ;
-- Was BIT_PRIM rather than BIT_INLINE.
AGbit_prim . BIT_INLINE ::= BIT_INLINE_DEF CLOSING ";" ;
AZbit_prim . BIT_INLINE ::= BIT_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAbit_inline_def . BIT_INLINE_DEF ::= "FUNCTION" BIT_SPEC ";" ;
-- Was CHAR_PRIM rather than CHAR_INLINE.
ADchar_prim . CHAR_INLINE ::= CHAR_INLINE_DEF CLOSING ";" ;
AZchar_prim . CHAR_INLINE ::= CHAR_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAchar_inline_def . CHAR_INLINE_DEF ::= "FUNCTION" CHAR_SPEC ";" ;
ACstructure_exp . STRUCTURE_EXP ::= STRUC_INLINE_DEF CLOSING ";" ;
AEstructure_exp . STRUCTURE_EXP ::= STRUC_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAstruc_inline_def . STRUC_INLINE_DEF ::= "FUNCTION" STRUCT_SPEC ";" ;

--------------------------------------------------------------------------
-- Some leftovers.
AEprimary . PRIMARY ::= PRE_PRIMARY QUALIFIER ;
ABany_statement . ANY_STATEMENT ::= BLOCK_DEFINITION ;
--AAarithFuncInteger . ARITH_FUNC ::= "INTEGER" ;
AAcharFuncCharacter . CHAR_FUNC ::= "CHARACTER" ;
--AAarithFuncScalar . ARITH_FUNC ::= "SCALAR" ;

--------------------------------------------------------------------------
-- The following rules are commented out "permanently" because they  
-- involve NO_ARG_xxxxx_FUNC types, which as far as I know don't exist.
-- But I'll keep them around in case I was wrong and some of these 
-- functions pop up later.
{-
ABstructure_exp . STRUCTURE_EXP ::= MODIFIED_STRUCT_FUNC ;
AAmodified_struct_func . MODIFIED_STRUCT_FUNC ::= NO_ARG_STRUCT_FUNC ;
ACmodified_struct_func . MODIFIED_STRUCT_FUNC ::= NO_ARG_STRUCT_FUNC SUBSCRIPT ;
ABmodified_struct_func . MODIFIED_STRUCT_FUNC ::= QUAL_STRUCT "." NO_ARG_STRUCT_FUNC ;
ADmodified_struct_func . MODIFIED_STRUCT_FUNC ::= QUAL_STRUCT "."  NO_ARG_STRUCT_FUNC SUBSCRIPT ;
ZZnoArgStructFunc. NO_ARG_STRUCT_FUNC ::= EMPTY ;

AFbit_prim . BIT_PRIM ::= MODIFIED_BIT_FUNC ;
AAmodified_bit_func . MODIFIED_BIT_FUNC ::= NO_ARG_BIT_FUNC ;
ACmodified_bit_func . MODIFIED_BIT_FUNC ::= NO_ARG_BIT_FUNC SUBSCRIPT ;
ABmodified_bit_func . MODIFIED_BIT_FUNC ::= QUAL_STRUCT "." NO_ARG_BIT_FUNC ;
ADmodified_bit_func . MODIFIED_BIT_FUNC ::= QUAL_STRUCT "." NO_ARG_BIT_FUNC SUBSCRIPT ;
ZZnoArgBitFunc. NO_ARG_BIT_FUNC ::= EMPTY ;

ACchar_prim . CHAR_PRIM ::= MODIFIED_CHAR_FUNC ;
AAmodified_char_func . MODIFIED_CHAR_FUNC ::= NO_ARG_CHAR_FUNC ;
AAmodified_char_func . MODIFIED_CHAR_FUNC ::= NO_ARG_CHAR_FUNC SUBSCRIPT ;
ABmodified_char_func . MODIFIED_CHAR_FUNC ::= QUAL_STRUCT "." NO_ARG_CHAR_FUNC ;
ABmodified_char_func . MODIFIED_CHAR_FUNC ::= QUAL_STRUCT "."  NO_ARG_CHAR_FUNC SUBSCRIPT ;
ZZnoArgCharFunc. NO_ARG_CHAR_FUNC ::= EMPTY ;

ADname_var . NAME_VAR ::= MODIFIED_BIT_FUNC ;
AEname_var . NAME_VAR ::= MODIFIED_CHAR_FUNC ;
AFname_var . NAME_VAR ::= MODIFIED_STRUCT_FUNC ;
-}


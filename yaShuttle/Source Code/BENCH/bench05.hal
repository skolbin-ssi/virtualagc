 MATVECD4: PROGRAM;
C
   REPLACE ITER_CNT BY "300";
   REPLACE DIM BY "4";
   REPLACE PREC BY "DOUBLE";
C
C PURPOSE:  TO TEST HAL/S SINGLE/DOUBLE 3-VECTOR (3,3 MATRIX) AND
C           4-VECTOR (4,4) MATRIX LOGIC, AND ALSO SINGLE AND DOUBLE
C           PRECISION SCALARS AND SCALAR ARRAYS.
C
C TEST IDENTIFICATION NUMBERS
C
C   TEST # 1 -   SCALAR VECTOR
C          2 -   VECTOR / SCALAR
C          3 -   - VECTOR
C          4 -   VECTOR + VECTOR
C          5 -   VECTOR - VECTOR
C          6 -   UNIT(VECTOR)
C          7 -   VECTOR . VECTOR (DOT PRODUCT)
C          8 -   ABVAL(VECTOR)
C          9 -   SCALAR MATRIX
C         10 -   MATRIX / SCALAR
C         11 -   - MATRIX
C         12 -   MATRIX + MATRIX
C         13 -   MATRIX - MATRIX
C         14 -   MATRIX MATRIX
C         15 -   MATRIX VECTOR
C         16 -   VECTOR MATRIX
C         17 -   MATRIX**T (TRANSPOSE)
C         18 -   VECTOR VECTOR (MATRIX RESULT)
C         19 -   DET(MATRIX)
C         20 -   INVERSE(MATRIX)
C         21 -   TRACE(MATRIX)
C         22 -   VECTOR * VECTOR (3 DIMENSIONS ONLY)
C
C ERROR TOLERANCE
C
  DECLARE TOLS ARRAY(22) SCALAR PREC INITIAL(5#0,1.48E-9,7.07E-13,
    0,0,0,0,0,0,0,2.99E-15,0,0,0,1.27E-6,1.31E-7,0,0);
  DECLARE MAXERR ARRAY(22) SCALAR PREC INITIAL(0);
  DECLARE TEST_DEFS ARRAY(22) CHARACTER(10) INITIAL(
    'S V       ',
    'V / S     ',
    '- V       ',
    'V + V     ',
    'V - V     ',
    'UNIT(V)   ',
    'V . V     ',
    'ABVAL(V)  ',
    'S M       ',
    'M / S     ',
    '- M       ',
    'M + M     ',
    'M - M     ',
    'M M       ',
    'M V       ',
    'V M       ',
    'M**T      ',
    'V V       ',
    'DET(M)    ',
    'M**-1     ',
    'TRACE(M)  ',
    'V * V     ');
  DECLARE TEST_NDX INTEGER INITIAL(0);
C
C VARIABLES FOR RANDOM NUMBER GENERATOR
C
  DECLARE RM INTEGER DOUBLE INITIAL(2**20);
  DECLARE FM SCALAR DOUBLE CONSTANT(2**20);
  DECLARE RA INTEGER DOUBLE CONSTANT(2**10 + 3);
  DECLARE RX INTEGER DOUBLE INITIAL(566387);
C
C LOCAL VARIABLES
C
  DECLARE INTEGER DOUBLE, TEST_NUM, FAIL_CTR INITIAL(0);
  DECLARE SCALAR PREC, K1, K2, EXP_VAL ARRAY(5), SCALE_VAL ARRAY(5);
  DECLARE SCALAR PREC, DETM;
  DECLARE VECTOR(DIM) PREC, X, Y, Z;
  DECLARE MATRIX(DIM,DIM) PREC, P, Q, R;
  DECLARE ARRAY(DIM) SCALAR PREC, XX, YY, ZZ;
  DECLARE ARRAY(DIM,DIM) SCALAR PREC, PP, QQ, RR;
C
 RANDFUNC: PROCEDURE (LOWLIM, HIGHLIM) ASSIGN (OUTVAL);
  DECLARE SCALAR PREC, LOWLIM, HIGHLIM;
  DECLARE SCALAR PREC, OUTVAL;
  DECLARE SCALAR DOUBLE, TEMP;
  RX = MOD(RA RX,RM);
  TEMP = RX/FM;
  OUTVAL = (1 - TEMP) LOWLIM + TEMP HIGHLIM;
  CLOSE RANDFUNC;
C
 CHECK_VECTOR: PROCEDURE(VEC, ARR);
  DECLARE VEC VECTOR(DIM) PREC;
  DECLARE ARR ARRAY(DIM) SCALAR PREC;
  DECLARE SCALAR PREC, ERRS, ABSERR;
  DO FOR TEMPORARY IX = 1 TO DIM;
    ERRS = (VEC$(IX) - ARR$(IX))/(1 + ABS(VEC$(IX)));
    ABSERR = ABS(ERRS);
    IF ABSERR > MAXERR$(TEST_NDX) THEN
      MAXERR$(TEST_NDX) = ABSERR;
    IF ABSERR > TOLS$(TEST_NDX) THEN
      DO;
        WRITE(6) TEST_DEFS$(TEST_NDX:), TEST_NUM, IX, VEC$(IX),
          ARR$(IX), ERRS;
        FAIL_CTR = FAIL_CTR + 1;
      END;
  END;
 CLOSE CHECK_VECTOR;
C
 CHECK_MATRIX: PROCEDURE(MAT, ARR);
  DECLARE MAT MATRIX(DIM,DIM) PREC;
  DECLARE ARR ARRAY(DIM,DIM) SCALAR PREC;
  DECLARE SCALAR PREC, ERRS, ABSERR;
  DO FOR TEMPORARY IX = 1 TO DIM;
    DO FOR TEMPORARY JX = 1 TO DIM;
      ERRS = (MAT$(IX,JX) - ARR$(IX,JX))/(1 + ABS(MAT$(IX,JX)));
      ABSERR = ABS(ERRS);
      IF ABSERR > MAXERR$(TEST_NDX) THEN
        MAXERR$(TEST_NDX) = ABSERR;
      IF ABSERR > TOLS$(TEST_NDX) THEN
        DO;
          WRITE(6) TEST_DEFS$(TEST_NDX:), TEST_NUM, IX, JX,
            MAT$(IX,JX),ARR$(IX,JX), ERRS;
          FAIL_CTR = FAIL_CTR + 1;
        END;
    END;
  END;
 CLOSE CHECK_MATRIX;
C
 SCALAR_VECTOR: PROCEDURE(TYPE, A, B) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, B, C;
   DECLARE SCALAR PREC, A;
   DECLARE INTEGER SINGLE, TYPE;
   DO FOR TEMPORARY IX = 1 TO DIM;
     IF TYPE = 1 THEN
       C$(IX) = A B$(IX);
     ELSE
       C$(IX) = B$(IX) / A;
   END;
 CLOSE SCALAR_VECTOR;
C
 VECTOR_NEGATE: PROCEDURE(A) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, A, C;
   DO FOR TEMPORARY IX = 1 TO DIM;
     C$(IX) = - A$(IX);
   END;
 CLOSE VECTOR_NEGATE;
C
 VECTOR_ADD: PROCEDURE(TYPE,A, B) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, A, B, C;
   DECLARE INTEGER SINGLE, TYPE;
   DO FOR TEMPORARY IX = 1 TO DIM;
     IF TYPE = 1 THEN
       C$(IX) = A$(IX) + B$(IX);
     ELSE
       C$(IX) = A$(IX) - B$(IX);
   END;
 CLOSE VECTOR_ADD;
C
 VECTOR_ABVAL: PROCEDURE(A) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, A;
   DECLARE SCALAR PREC, C, CSUM;
   CSUM = 0;
   DO FOR TEMPORARY IX = 1 TO DIM;
     CSUM = CSUM + A$(IX)**2;
   END;
   C = SQRT(CSUM);
 CLOSE VECTOR_ABVAL;
C
 VECTOR_DOT: PROCEDURE(A, B) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, A, B;
   DECLARE SCALAR PREC, C;
   C = 0;
   DO FOR TEMPORARY IX = 1 TO DIM;
     C = C + A$(IX) B$(IX);
   END;
 CLOSE VECTOR_DOT;
C
 SCALAR_MATRIX: PROCEDURE(TYPE, A, B) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, B, C;
   DECLARE SCALAR PREC, A;
   DECLARE INTEGER SINGLE, TYPE;
   DO FOR TEMPORARY IX = 1 TO DIM;
     DO FOR TEMPORARY JX = 1 TO DIM;
       IF TYPE = 1 THEN
         C$(IX,JX) = A B$(IX,JX);
       ELSE
         C$(IX,JX) = B$(IX,JX) / A;
     END;
   END;
 CLOSE SCALAR_MATRIX;
C
 MATRIX_NEGATE: PROCEDURE(A) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A, C;
   DO FOR TEMPORARY IX = 1 TO DIM;
     DO FOR TEMPORARY JX = 1 TO DIM;
       C$(IX,JX) = - A$(IX,JX);
     END;
   END;
 CLOSE MATRIX_NEGATE;
C
 MATRIX_ADD: PROCEDURE(TYPE,A, B) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A, B, C;
   DECLARE INTEGER SINGLE, TYPE;
   DO FOR TEMPORARY IX = 1 TO DIM;
     DO FOR TEMPORARY JX = 1 TO DIM;
       IF TYPE = 1 THEN
         C$(IX,JX) = A$(IX,JX) + B$(IX,JX);
       ELSE
         C$(IX,JX) = A$(IX,JX) - B$(IX,JX);
     END;
   END;
 CLOSE MATRIX_ADD;
C
 MATRIX_MULTIPLY: PROCEDURE(A, B) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A, B, C;
   DO FOR TEMPORARY IX = 1 TO DIM;
     DO FOR TEMPORARY JX = 1 TO DIM;
       C$(IX,JX) = 0;
       DO FOR TEMPORARY KX = 1 TO DIM;
         C$(IX,JX) = A$(IX,KX) B$(KX,JX) + C$(IX,JX);
       END;
     END;
   END;
 CLOSE MATRIX_MULTIPLY;
C
 MATRIX_VECTOR: PROCEDURE(TYPE,A, B) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A;
   DECLARE ARRAY(DIM) SCALAR PREC, B, C;
   DECLARE INTEGER SINGLE, TYPE;
   DO FOR TEMPORARY IX = 1 TO DIM;
     C$(IX) = 0;
     DO FOR TEMPORARY JX = 1 TO DIM;
       IF TYPE = 1 THEN
         C$(IX) = C$(IX) + A$(IX,JX) B$(JX);
       ELSE
         C$(IX) = C$(IX) + B$(JX) A$(JX,IX);
     END;
   END;
 CLOSE MATRIX_VECTOR;
C
 MATRIX_TRANSPOSE: PROCEDURE(A) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A, C;
   DO FOR TEMPORARY IX = 1 TO DIM;
     DO FOR TEMPORARY JX = 1 TO DIM;
       C$(IX,JX) = A$(JX,IX);
     END;
   END;
 CLOSE MATRIX_TRANSPOSE;
C
C VECTOR OUTER PRODUCT
C
 VECTOR_OUTER: PROCEDURE(A,B) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, A, B;
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, C;
   DO FOR TEMPORARY IX = 1 TO DIM;
     DO FOR TEMPORARY JX = 1 TO DIM;
       C$(IX,JX) = A$(IX) B$(JX);
     END;
   END;
 CLOSE VECTOR_OUTER;
C
 MATRIX_DET: PROCEDURE(A) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A;
   DECLARE SCALAR PREC, C;
C  C = A$(1,1) (A$(2,2)A$(3,3)-A$(3,2)A$(2,3))
C    - A$(1,2) (A$(2,1)A$(3,3)-A$(3,1)A$(2,3))
C    + A$(1,3) (A$(2,1)A$(3,2)-A$(3,1)A$(2,2));
   C = A$(1,1) A$(2,2) (A$(3,3)A$(4,4)-A$(4,3)A$(3,4))
     - A$(1,1) A$(2,3) (A$(3,2)A$(4,4)-A$(4,2)A$(3,4))
     + A$(1,1) A$(2,4) (A$(3,2)A$(4,3)-A$(4,2)A$(3,3));
   C = C - A$(1,2) A$(2,1) (A$(3,3)A$(4,4)-A$(4,3)A$(3,4))
     + A$(1,2) A$(2,3) (A$(3,1)A$(4,4)-A$(4,1)A$(3,4))
     - A$(1,2) A$(2,4) (A$(3,1)A$(4,3)-A$(4,1)A$(3,3));
   C = C  + A$(1,3) A$(2,1) (A$(3,2)A$(4,4)-A$(4,2)A$(3,4))
     - A$(1,3) A$(2,2) (A$(3,1)A$(4,4)-A$(4,1)A$(3,4))
     + A$(1,3) A$(2,4) (A$(3,1)A$(4,2)-A$(4,1)A$(3,2));
   C = C  - A$(1,4) A$(2,1) (A$(3,2)A$(4,3)-A$(4,2)A$(3,3))
     + A$(1,4) A$(2,2) (A$(3,1)A$(4,3)-A$(4,1)A$(3,3))
     - A$(1,4) A$(2,3) (A$(3,1)A$(4,2)-A$(4,1)A$(3,2));
 CLOSE MATRIX_DET;
C
 MATRIX_INVERSE: PROCEDURE(A,B) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A, C;
   DECLARE SCALAR PREC, B;
   C$(1,1) =  (A$(2,2)(A$(3,3)A$(4,4)-A$(4,3)A$(3,4))
              -A$(2,3)(A$(3,2)A$(4,4)-A$(4,2)A$(3,4))
              +A$(2,4)(A$(3,2)A$(4,3)-A$(4,2)A$(3,3)))/B;
   C$(1,2) = -(A$(1,2)(A$(3,3)A$(4,4)-A$(4,3)A$(3,4))
              -A$(1,3)(A$(3,2)A$(4,4)-A$(4,2)A$(3,4))
              +A$(1,4)(A$(3,2)A$(4,3)-A$(4,2)A$(3,3)))/B;
   C$(1,3) =  (A$(1,2)(A$(2,3)A$(4,4)-A$(4,3)A$(2,4))
              -A$(1,3)(A$(2,2)A$(4,4)-A$(4,2)A$(2,4))
              +A$(1,4)(A$(2,2)A$(4,3)-A$(4,2)A$(2,3)))/B;
   C$(1,4) = -(A$(1,2)(A$(2,3)A$(3,4)-A$(3,3)A$(2,4))
              -A$(1,3)(A$(2,2)A$(3,4)-A$(3,2)A$(2,4))
              +A$(1,4)(A$(2,2)A$(3,3)-A$(3,2)A$(2,3)))/B;
   C$(2,1) = -(A$(2,1)(A$(3,3)A$(4,4)-A$(4,3)A$(3,4))
              -A$(2,3)(A$(3,1)A$(4,4)-A$(4,1)A$(3,4))
              +A$(2,4)(A$(3,1)A$(4,3)-A$(4,1)A$(3,3)))/B;
   C$(2,2) =  (A$(1,1)(A$(3,3)A$(4,4)-A$(4,3)A$(3,4))
              -A$(1,3)(A$(3,1)A$(4,4)-A$(4,1)A$(3,4))
              +A$(1,4)(A$(3,1)A$(4,3)-A$(4,1)A$(3,3)))/B;
   C$(2,3) = -(A$(1,1)(A$(2,3)A$(4,4)-A$(4,3)A$(2,4))
              -A$(1,3)(A$(2,1)A$(4,4)-A$(4,1)A$(2,4))
              +A$(1,4)(A$(2,1)A$(4,3)-A$(4,1)A$(2,3)))/B;
   C$(2,4) =  (A$(1,1)(A$(2,3)A$(3,4)-A$(3,3)A$(2,4))
              -A$(1,3)(A$(2,1)A$(3,4)-A$(3,1)A$(2,4))
              +A$(1,4)(A$(2,1)A$(3,3)-A$(3,1)A$(2,3)))/B;
   C$(3,1) =  (A$(2,1)(A$(3,2)A$(4,4)-A$(4,2)A$(3,4))
              -A$(2,2)(A$(3,1)A$(4,4)-A$(4,1)A$(3,4))
              +A$(2,4)(A$(3,1)A$(4,2)-A$(4,1)A$(3,2)))/B;
   C$(3,2) = -(A$(1,1)(A$(3,2)A$(4,4)-A$(4,2)A$(3,4))
              -A$(1,2)(A$(3,1)A$(4,4)-A$(4,1)A$(3,4))
              +A$(1,4)(A$(3,1)A$(4,2)-A$(4,1)A$(3,2)))/B;
   C$(3,3) =  (A$(1,1)(A$(2,2)A$(4,4)-A$(4,2)A$(2,4))
              -A$(1,2)(A$(2,1)A$(4,4)-A$(4,1)A$(2,4))
              +A$(1,4)(A$(2,1)A$(4,2)-A$(4,1)A$(2,2)))/B;
   C$(3,4) = -(A$(1,1)(A$(2,2)A$(3,4)-A$(3,2)A$(2,4))
              -A$(1,2)(A$(2,1)A$(3,4)-A$(3,1)A$(2,4))
              +A$(1,4)(A$(2,1)A$(3,2)-A$(3,1)A$(2,2)))/B;
   C$(4,1) = -(A$(2,1)(A$(3,2)A$(4,3)-A$(4,2)A$(3,3))
              -A$(2,2)(A$(3,1)A$(4,3)-A$(4,1)A$(3,3))
              +A$(2,3)(A$(3,1)A$(4,2)-A$(4,1)A$(3,2)))/B;
   C$(4,2) =  (A$(1,1)(A$(3,2)A$(4,3)-A$(4,2)A$(3,3))
              -A$(1,2)(A$(3,1)A$(4,3)-A$(4,1)A$(3,3))
              +A$(1,3)(A$(3,1)A$(4,2)-A$(4,1)A$(3,2)))/B;
   C$(4,3) = -(A$(1,1)(A$(2,2)A$(4,3)-A$(4,2)A$(2,3))
              -A$(1,2)(A$(2,1)A$(4,3)-A$(4,1)A$(2,3))
              +A$(1,3)(A$(2,1)A$(4,2)-A$(4,1)A$(2,2)))/B;
   C$(4,4) =  (A$(1,1)(A$(2,2)A$(3,3)-A$(3,2)A$(2,3))
              -A$(1,2)(A$(2,1)A$(3,3)-A$(3,1)A$(2,3))
              +A$(1,3)(A$(2,1)A$(3,2)-A$(3,1)A$(2,2)))/B;
 CLOSE MATRIX_INVERSE;
C
 MATRIX_TRACE: PROCEDURE(A) ASSIGN(C);
   DECLARE ARRAY(DIM,DIM) SCALAR PREC, A;
   DECLARE SCALAR PREC, C;
   C = 0;
   DO FOR TEMPORARY IX = 1 TO DIM;
     C = C + A$(IX,IX);
   END;
 CLOSE MATRIX_TRACE;
C
C VECTOR CROSS-PRODUCT
C
 VECTOR_CROSS: PROCEDURE(A,B) ASSIGN(C);
   DECLARE ARRAY(DIM) SCALAR PREC, A, B, C;
 CLOSE VECTOR_CROSS;
C
 MATVEC_SUB: PROCEDURE;
C
C GENERATE FIVE RANDOM NUMBERS TO DECIDE ON APPROXIMATE MAGNITUDE
C OF SCALARS, VECTORS, AND MATRICES.
C
   DO FOR TEMPORARY IX = 1 TO 5;
     CALL RANDFUNC(-5,5) ASSIGN(EXP_VAL$IX);
     SCALE_VAL$IX = 10**EXP_VAL$IX;
   END;
C
C CREATE A RANDOM SCALAR
C
   CALL RANDFUNC(-SCALE_VAL$1,SCALE_VAL$1) ASSIGN(K1);
C
C CREATE VECTORS X & Y AND MATRICES P & Q
C
   DO FOR TEMPORARY IX = 1 TO DIM;
     CALL RANDFUNC(-SCALE_VAL$2,SCALE_VAL$2) ASSIGN(X$(IX));
     CALL RANDFUNC(-SCALE_VAL$3,SCALE_VAL$3) ASSIGN(Y$(IX));
     DO FOR TEMPORARY JX = 1 TO DIM;
       CALL RANDFUNC(-SCALE_VAL$4,SCALE_VAL$4) ASSIGN (P$(IX,JX));
       CALL RANDFUNC(-SCALE_VAL$5,SCALE_VAL$5) ASSIGN (Q$(IX,JX));
     END;
   END;
C
C NOW COPY THE VALUES INTO THE EQUIVALENT ARRAYS
C
   DO FOR TEMPORARY IX = 1 TO DIM;
     XX$(IX) = X$(IX);
     YY$(IX) = Y$(IX);
     DO FOR TEMPORARY JX = 1 TO DIM;
       PP$(IX,JX) = P$(IX,JX);
       QQ$(IX,JX) = Q$(IX,JX);
     END;
   END;
C
C SCALAR * VECTOR
C
   TEST_NDX = 1;
   Z = K1 X;
   CALL SCALAR_VECTOR(1, K1, XX) ASSIGN(ZZ);
   CALL CHECK_VECTOR(Z,ZZ);
C
C VECTOR / SCALAR
C
   TEST_NDX = 2;
   IF ABS(K1) > 1.0E-20 THEN DO;
     Z = X / K1;
     CALL SCALAR_VECTOR(2, K1, XX) ASSIGN(ZZ);
     CALL CHECK_VECTOR(Z,ZZ);
   END;
C
C - VECTOR
C
   TEST_NDX = 3;
   Z = - X;
   CALL VECTOR_NEGATE(XX) ASSIGN(ZZ);
   CALL CHECK_VECTOR(Z,ZZ);
C
C VECTOR + VECTOR
C
   TEST_NDX = 4;
   Z = X + Y;
   CALL VECTOR_ADD(1, XX, YY) ASSIGN(ZZ);
   CALL CHECK_VECTOR(Z,ZZ);
C
C VECTOR - VECTOR
C
   TEST_NDX = 5;
   Z = X - Y;
   CALL VECTOR_ADD(2, XX, YY) ASSIGN(ZZ);
   CALL CHECK_VECTOR(Z,ZZ);
C
C UNIT(VECTOR)
C
   TEST_NDX = 6;
   Z = UNIT(X);
   CALL VECTOR_ABVAL(XX) ASSIGN(K2);
   IF ABS(K2) > 1.0E-20 THEN DO;
     ZZ = XX/K2;
     CALL CHECK_VECTOR(Z,ZZ);
   END;
C
C VECTOR . VECTOR (DOT PRODUCT)
C NOTE:  WE USE Z(1) AS A SCALAR; SINCE BOTH Z AND ZZ ARE PRE-ZEROED,
C        WE CAN EMPLOY OUR CHECK_VECTOR ROUTINE RATHER THAN HAVING TO
C        INTRODUCE A CHECK_SCALAR!
C
   TEST_NDX = 7;
   Z = 0; ZZ = 0;
   Z$1 = X . Y;
   CALL VECTOR_DOT(XX,YY) ASSIGN(ZZ$1);
   CALL CHECK_VECTOR(Z,ZZ);
C
C ABVAL(VECTOR)
C
   TEST_NDX = 8;
   Z = 0; ZZ = 0;
   Z$1 = ABVAL(X);
   CALL VECTOR_ABVAL(XX) ASSIGN(ZZ$1);
   CALL CHECK_VECTOR(Z,ZZ);
C
C SCALAR * MATRIX
C
   TEST_NDX = 9;
   R = K1 P;
   CALL SCALAR_MATRIX(1, K1, PP) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C MATRIX / SCALAR
C
   TEST_NDX = 10;
   IF ABS(K1) > 1.0E-20 THEN DO;
     R = P / K1;
     CALL SCALAR_MATRIX(2, K1, PP) ASSIGN(RR);
     CALL CHECK_MATRIX(R,RR);
   END;
C
C - MATRIX
C
   TEST_NDX = 11;
   R = - P;
   CALL MATRIX_NEGATE(PP) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C MATRIX + MATRIX
C
   TEST_NDX =  12;
   R = P + Q;
   CALL MATRIX_ADD(1,PP,QQ) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C MATRIX - MATRIX
C
   TEST_NDX = 13;
   R = P - Q;
   CALL MATRIX_ADD(2,PP,QQ) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C MATRIX * MATRIX
C
   TEST_NDX = 14;
   R = P Q;
   CALL MATRIX_MULTIPLY(PP,QQ) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C MATRIX * VECTOR
C
   TEST_NDX = 15;
   Z = P X;
   CALL MATRIX_VECTOR(1,PP,XX) ASSIGN(ZZ);
   CALL CHECK_VECTOR(Z,ZZ);
C
C VECTOR * MATRIX
C
   TEST_NDX = 16;
   Z = X P;
   CALL MATRIX_VECTOR(2,PP,XX) ASSIGN(ZZ);
   CALL CHECK_VECTOR(Z,ZZ);
C
C MATRIX TRANSPOSE
C
   TEST_NDX = 17;
   R = P**T;
   CALL MATRIX_TRANSPOSE(PP) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C VECTOR OUTER PRODUCT
C
   TEST_NDX = 18;
   R = X Y;
   CALL VECTOR_OUTER(XX,YY) ASSIGN(RR);
   CALL CHECK_MATRIX(R,RR);
C
C DET(MATRIX)
C
   TEST_NDX = 19;
   Z = 0; ZZ = 0;
   Z$1,DETM = DET(P);
   CALL MATRIX_DET(PP) ASSIGN(ZZ$1);
   CALL CHECK_VECTOR(Z,ZZ);
C
C INVERSE(MATRIX)
C
   IF ABS(DETM) > 1.0E-10 THEN DO;
     TEST_NDX = 20;
     Q = P**(-1);
     CALL MATRIX_INVERSE(PP,DETM) ASSIGN(QQ);
     CALL CHECK_MATRIX(Q,QQ);
   END;
C
C TRACE(MATRIX)
C
   TEST_NDX = 21;
   Z = 0; ZZ = 0;
   Z$1 = TRACE(P);
   CALL MATRIX_TRACE(PP) ASSIGN(ZZ$1);
   CALL CHECK_VECTOR(Z,ZZ);
C
C VECTOR CROSS PRODUCT (3-VECTOR ONLY)
C
   TEST_NDX = 22;
C
 CLOSE MATVEC_SUB;
C
C CYCLE THE TEST CASE 'N' TIMES
C
   WRITE(6) '*** TEST INITIATED *** --',ITER_CNT,' ITERATIONS';
   DO FOR TEST_NUM = 1 TO ITER_CNT;
     CALL MATVEC_SUB;
   END;
C
C WE ARE DONE WITH THE TEST: SUMMARIZE THE RESULTS
C
  WRITE(6) '*** TEST COMPLETED ***';
  WRITE(6) 'TEST DEFN. ','MAX ERROR     ','TOLERANCE';
  DO FOR TEMPORARY I = 1 TO 22;
    WRITE(6) TEST_DEFS$(I:), MAXERR$(I:), TOLS$(I:);
  END;
  IF FAIL_CTR = 0 THEN
    DO;
      WRITE(6) 'TEST SUCCESSFUL -- ALL RESULTS WITHIN TOLERANCE';
    END;
  ELSE
    DO;
      WRITE(6) '*** TEST FAILURE --',FAIL_CTR,
        'VALUES WERE OUTSIDE OF TOLERANCE';
    END;
  RETURN;
  CLOSE MATVECD4;

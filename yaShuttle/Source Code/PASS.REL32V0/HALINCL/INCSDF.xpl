 /*@
    Access:     Public Domain, no restrictions believed to exist.
    Filename:   INCSDF.xpl
    Purpose:    Part of the HAL/S-FC compiler.
    Reference:  "HAL/S-FC & HAL/S-360 Compiler System Program Description", 
                section TBD.
    Language:   XPL.
    Contact:    The Virtual AGC Project (www.ibiblio.org/apollo).
    History:    2022-12-08 RSB  Suffixed the filename with ".xpl".
    Note:       Inline comments beginning with "/*@" were created by the 
                Virtual AGC Project. Inline comments beginning merely with 
                "/*" are from the original Space Shuttle development.
 */
 
/***************************************************************************/
/*                                                                         */
/* REVISION HISTORY:                                                       */
/*                                                                         */
/* DATE     WHO  RLS   DR/CR #  DESCRIPTION                                */
/*                                                                         */
/* 01/21/91 TKK  23V2  CR11098  DELETE SPILL CODE FROM COMPILER            */
/*                                                                         */
/* 07/08/91 RSJ  24V0  CR11096F IMPLEMENT THE INCREMENTAL #D OPTION        */
/*                                                                         */
/* 09/04/91 DAS  24V0  CR11120  #DFLAG - COMSUB REMOTE FLAG NOT SET,       */
/*                              SO MUST LOOK AT SDF DATA_REMOTE FLAG       */
/*                                                                         */
/* 12/23/92 PMA  8V0   *        MERGED 7V0 AND 24V0 COMPILERS.             */
/*                              * REFERENCE 24V0 CR/DRS                    */
/*                                                                         */
/* 01/02/97 DCP  28V0/ DR109040 NAME TASK DECLARED IN COMPOOL GETS         */
/*               12V0           EN4 ERROR                                  */
/*                                                                         */
/* 12/02/97 JAC  29V0  DR109074 DOWNGRADE OF DI21 ERROR FAILS WHEN         */
/*               14V0           INCLUDING A REMOTELY INCLUDED COMPOOL      */
/*                                                                         */
/* 12/11/97 DCP  29V0/ DR109083 CONSTANT DOUBLE SCALAR CONVERTED TO A      */
/*               14V0           CHARACTER AS SINGLE PRECISION              */
/*                                                                         */
/* 04/26/01 DCP  31V0/ CR13335  ALLEVIATE SOME DATA SPACE PROBLEMS IN      */
/*               16V0           HAL/S COMPILER                             */
/*                                                                         */
/* 10/17/00 TKN  31V0/ DR111350 COMPILER PHASE3 LISTING INCORRECT          */
/*               16V0                                                      */
/*                                                                         */
/***************************************************************************/
   /* ROUTINE TO INCLUDE VARIABLES FROM AN EXTERNAL UNIT'S SDF */

INCLUDE_SDF:
PROCEDURE(UNIT, INCL_FLAGS) BIT(1);

   DECLARE UNIT CHARACTER,
           INCL_FLAGS BIT(8);

   DECLARE  (NEXT_SYMBOL,CUR_SYMBOL,LAST_COMSUB_SYMB,UNIT_SYMB#) BIT(16),
            ACCESS_COMPOOL BIT(1) INITIAL(FALSE),
            TEMP_PTR FIXED,
            (I,J) BIT(16),
            SDF_NAME CHARACTER,
            (BLK_TYPE, #BLK_SYMBS, #SDF_PAGES) BIT(16);
   DECLARE  FLAGS FIXED,
            REV BIT(16),
            CAT BIT(16),
            REVSTR CHARACTER,
            #BLK_FLAGS LITERALLY '3';               /*CR13335*/
   ARRAY    IN_BLK_FLAG(#BLK_FLAGS) BIT(8)          /*CR13335*/
               CONSTANT("80","40","20","10"),
            OUT_BLK_FLAG(#BLK_FLAGS) FIXED
               CONSTANT(REENTRANT_FLAG,EXCLUSIVE_FLAG,ACCESS_FLAG,RIGID_FLAG);

            /* DECLARATIONS FOR %COPY CHECKING */

   DECLARE  CSECT_LENGTH(2) BIT(16), /* LENGTHS OF APPROPRIATE CSECTS   */
            PRIMARY_LENGTH LITERALLY 'CSECT_LENGTH(0)',
            REMOTE_LENGTH  LITERALLY 'CSECT_LENGTH(1)',
            SDF_VAR_CLASS LITERALLY '1'; /* INDICATES A VARIABLE */

   DECLARE  MAKESTRING(2) LITERALLY 'STRING(SHL(%1%-1,24)+%2%)',
            NEW_STRING(1) LITERALLY 'SUBSTR(X1||%1%,1)',
            INCLUDABLE_VERSION# LITERALLY '26';
   DECLARE SDF_VERSION# BIT(16);
   /*-CR11120 ----------------- #DFLAG -------------------------*/
   /*#DFLAG - MUST LOOK AT SDF ROOT DATA_REMOTE FLAG TO TELL IF */
   /*#DFLAG - MODULE WE'RE INCLUDING GOES REMOTE IN PRELINKER.  */
   DECLARE SDF_ROOT_FLAGS BIT(16);
   /*-----------------------------------------------------------*/

   /* SDF DECLARES */
   BASED SDF_B BIT(8), SDF_H BIT(16), SDF_F FIXED;
   DECLARE  /* FIELDS WITHIN AN SDF SYMBOL NODE */
            SDF_SYMB_FLAGS        LITERALLY 'SDF_F(2)',
            SDF_SYMB_LINK1        LITERALLY 'SDF_H(SDF_B(5)/2+1)',
            SDF_SYMB_LINK2        LITERALLY 'SDF_H(SDF_B(5)/2+2)',
            SDF_SYMB_DECLARE_LINK LITERALLY 'SDF_H(-5)',
            SDF_SYMB_ADDR         LITERALLY '(SDF_F(3)&"FFFFFF")',
            SDF_SYMB_EXTENT       LITERALLY '(SDF_F(5)&"00FFFFFF")',
            SDF_SYMB_LOCK#        LITERALLY 'SDF_B(20)',
            SDF_SYMB_ARRAY_OFF    LITERALLY 'SDF_B(4)',
            SDF_SYMB_ARRAY(1)     LITERALLY 'SDF_H(SHR(SDF_B(4),1)+1+%1%)',
            SDF_SYMB_NDIM         LITERALLY 'SDF_H(SHR(SDF_B(4),1))',
            SDF_SYMB_LIT_PTR      LITERALLY 'SDF_F(5)',
            SDF_SYMB_TYPE         LITERALLY 'SDF_B(7)',
            SDF_SYMB_VAR_LENGTH   LITERALLY 'SDF_H(9)',
            SDF_SYMB_CLASS        LITERALLY 'SDF_B(6)',
            SDF_SYMB_REPL_PTR     LITERALLY 'SDF_F(5)';
   DECLARE  /* DEFINE SYMB_FLAGS BITS */
            SDF_MISC_NAME_FLAG   LITERALLY '"00000010"',
            SDF_EXCLUSIVE_FLAG   LITERALLY '"00000040"',
            SDF_EXTERNAL_FLAG    LITERALLY '"00000800"',
            SDF_LIT_FLAG         LITERALLY '"00001000"',
            SDF_RIGID_FLAG       LITERALLY '"00002000"',
            SDF_INIT_FLAG        LITERALLY '"00004000"',
            SDF_REMOTE_FLAG      LITERALLY '"00010000"',
            SDF_LOCK_FLAG        LITERALLY '"00020000"',
            SDF_LATCH_FLAG       LITERALLY '"00040000"',
            SDF_ACCESS_FLAG      LITERALLY '"00100000"',
            SDF_CONSTANT_FLAG    LITERALLY '"00200000"',
            SDF_DENSE_FLAG       LITERALLY '"00400000"',
            SDF_REENTRANT_FLAG   LITERALLY '"00800000"',
            SDF_TPL_HDR_FLAG     LITERALLY '"02000000"',
            SDF_NAME_FLAG        LITERALLY '"04000000"',
            SDF_AUTO_FLAG        LITERALLY '"08000000"',
            SDF_TEMPORARY_FLAG   LITERALLY '"10000000"',
            SDF_ASSIGN_PARM_FLAG LITERALLY '"20000000"',
            SDF_INPUT_PARM_FLAG  LITERALLY '"40000000"',
            SDF_PARM_FLAGS LITERALLY
               '(SDF_INPUT_PARM_FLAG|SDF_ASSIGN_PARM_FLAG)';
   DECLARE  /* FIELDS AND VALUES WITHIN THE SDF DIRECTORY ROOT */
            SDF_ROOT_COMSUB_END LITERALLY 'SDF_H(59)',
            SDF_FC_FLAG         LITERALLY '"1000"',
            SDF_ROOT_LAST_PAGE  LITERALLY 'SDF_H(1)',
            SDF_ROOT_UNIT_SYMB# LITERALLY 'SDF_H(14)',
            SDF_ROOT_UNIT_BLK#  LITERALLY 'SDF_H(44)',
            SDF_ROOT_COMPILER   LITERALLY 'MAKESTRING(4,SDFPKG_LOC_ADDR+140)';
   DECLARE  /* FIELDS WITHIN AN SDF REPLACE CELL */
            SDF_REPL_ARG_CNT     LITERALLY '(-SDF_H(2)-1)',
            SDF_REPL_ARG_NAME(1) LITERALLY
               'STRING(SDFPKG_LOC_ADDR+SDF_F(1+%1%))',
            SDF_REPL_NEXT_PTR    LITERALLY 'SDF_F(0)',
            SDF_REPL_#BYTES      LITERALLY 'SDF_H(2)',
            SDF_REPL_TEXT_ADDR   LITERALLY 'SDFPKG_LOC_ADDR+6';
   DECLARE  /* FIELDS WITHIN AN SDF BLOCK DATA CELL */
            SDF_BLK_FIRST_SYMB#  LITERALLY 'SDF_H(16)',
            SDF_BLK_LAST_SYMB#   LITERALLY 'SDF_H(17)',
            SDF_BLK_VERSION#     LITERALLY 'SDF_B(25)',
            SDF_BLK_FLAGS        LITERALLY 'SDF_B(24)',
            SDF_BLK_CATEGORY     LITERALLY 'SDF_B(30)';
   /* DECLARES FOR SDFPKG */

   DECLARE  COMMTABL(29) FIXED;

   BASED    COMMTABL_BYTE BIT(8),
            COMMTABL_HALFWORD BIT(16),
            COMMTABL_FULLWORD FIXED;

   DECLARE  COMMTABL_ADDR FIXED;

   DECLARE  SDFPKG_APGAREA       LITERALLY 'COMMTABL_FULLWORD(0)',
            SDFPKG_AFCBAREA      LITERALLY 'COMMTABL_FULLWORD(1)',
            SDFPKG_NPAGES        LITERALLY 'COMMTABL_HALFWORD(4)',
            SDFPKG_NBYTES        LITERALLY 'COMMTABL_HALFWORD(5)',
            SDFPKG_MISC          LITERALLY 'COMMTABL_HALFWORD(6)',
            SDFPKG_CRETURN       LITERALLY 'COMMTABL_HALFWORD(7)',
            SDFPKG_BLKNO         LITERALLY 'COMMTABL_HALFWORD(8)',
            SDFPKG_SYMBNO        LITERALLY 'COMMTABL_HALFWORD(9)',
            SDFPKG_STMTNO        LITERALLY 'COMMTABL_HALFWORD(10)',
            SDFPKG_BLKNLEN       LITERALLY 'COMMTABL_BYTE(22)',
            SDFPKG_SYMBNLEN      LITERALLY 'COMMTABL_BYTE(23)',
            SDFPKG_LOC_PTR       LITERALLY 'COMMTABL_FULLWORD(6)',
            SDFPKG_LOC_ADDR      LITERALLY 'COMMTABL_FULLWORD(7)',
            SDFPKG_SDFNAM_ADDR   LITERALLY 'COMMTABL_ADDR+32',
            SDFPKG_SDFNAM        LITERALLY 'MAKESTRING(8,SDFPKG_SDFNAM_ADDR)',
            SDFPKG_CSECTNAM_ADDR LITERALLY 'COMMTABL_ADDR+40',
            SDFPKG_CSECTNAM      LITERALLY 'MAKESTRING(8,SDFPKG_CSECTNAM_ADDR)',
            SDFPKG_SREFNO_ADDR   LITERALLY 'COMMTABL_ADDR+48',
            SDFPKG_SREFNO        LITERALLY 'MAKESTRING(6,SDFPKG_SREFNO_ADDR)',
            SDFPKG_INCLCNT       LITERALLY 'COMMTABL_HALFWORD(27)',
            SDFPKG_BLKNAM_ADDR   LITERALLY 'COMMTABL_ADDR+56',
            SDFPKG_BLKNAM        LITERALLY
               'MAKESTRING(SDFPKG_BLKNLEN,SDFPKG_BLKNAM_ADDR)',
            SDFPKG_SYMBNAM_ADDR  LITERALLY 'COMMTABL_ADDR+88',
            SDFPKG_SYMBNAM       LITERALLY
               'MAKESTRING(SDFPKG_SYMBNLEN,SDFPKG_SYMBNAM_ADDR)',
            SDFPKG_PAGES_LEFT    BIT(16);
   BASED  PGING   RECORD:
            PAGEADDR   (420)    FIXED,
            END;
   BASED FORFCB   RECORD:
         FCBADDR   (128)  FIXED,
   END;
   /* SDFPKG CALLS */

   DECLARE CALL_SDFPKG(1) LITERALLY 'CALL MONITOR(22,%1%)',
           SET_SDF_BASED LITERALLY 'COREWORD(ADDR(SDF_B)),COREWORD(ADDR(SDF_H)),
COREWORD(ADDR(SDF_F))=SDFPKG_LOC_ADDR;',
            LOCATE_SDF_SYMB#(1) LITERALLY 'DO;SDFPKG_SYMBNO=%1%;CALL MONITOR(22,
9);SET_SDF_BASED;END;',
            LOCATE_SDF_PTR(1) LITERALLY 'DO;SDFPKG_LOC_PTR=%1%;CALL MONITOR(22,
5);SET_SDF_BASED;END;',
            LOCATE_SDF_SYMBNAME(1) LITERALLY 'DO;SDFPKG_SYMBNLEN=LENGTH(%1%);
CALL MOVE(SDFPKG_SYMBNLEN,%1%,SDFPKG_SYMBNAM_ADDR);CALL MONITOR(22,13);
SET_SDF_BASED;END;',
            LOCATE_SDF_ROOT LITERALLY
'DO;CALL MONITOR(22,7);SET_SDF_BASED;END;',
            LOCATE_SDF_BLOCK#(1) LITERALLY 'DO;SDFPKG_BLKNO=%1%;CALL MONITOR(22,
8);SET_SDF_BASED;END;',
            TERMINATE_SDFPKG LITERALLY 'DO;CALL MONITOR(22,1);SDF_OPEN=FALSE;END
';

FIND:
   PROCEDURE(NAME) BIT(16);
   /* FIND SYMBOL WITH GIVEN NAME, RETURNING ITS INDEX OR 0 IF NOT FOUND */

      DECLARE NAME CHARACTER;
      DECLARE I BIT(16);
      NAME_HASH = HASH(NAME, SYT_HASHSIZE);
      I = SYT_HASHSTART(NAME_HASH);
      DO WHILE I > 0;
         IF NAME = SYT_NAME(I) THEN RETURN I;
         I = SYT_HASHLINK(I);
      END;
      RETURN 0;
   END FIND;

DUPLICATE_NAME:
   PROCEDURE(NAME) BIT(1);
   /* CHECK TO SEE IF NAME ALREADY EXISTS IN THE SYMBOL TABLE IN A FORM */
   /* THAT IMPLIES A MULTIPLE DECLARATION ERROR.  SET STRUC. FLAGS      */

      DECLARE NAME CHARACTER;
      DECLARE I BIT(16);
      NAME_HASH = HASH(NAME, SYT_HASHSIZE);
      I = SYT_HASHSTART(NAME_HASH);
      DO WHILE I > 0;
         IF NAME = SYT_NAME(I) THEN DO;
            IF I < PROCMARK THEN RETURN FALSE;
            IF ^BUILDING_TEMPLATE THEN DO;
               IF SYT_CLASS(I) < TEMPLATE_CLASS THEN
                  RETURN TRUE;
               ELSE CALL SET_DUPL_FLAG(I);
            END;
            ELSE DO;
               SYT_FLAGS(REF_ID_LOC) = SYT_FLAGS(REF_ID_LOC) | DUPL_FLAG;
               IF SYT_CLASS(I) >= TEMPLATE_CLASS THEN
                  CALL SET_DUPL_FLAG(I);
            END;
         END;
         I = SYT_HASHLINK(I);
      END;
      RETURN FALSE;
   END DUPLICATE_NAME;

SET_SYT_FLAGS:
   PROCEDURE(NDX);
   /* SET SYT_FLAGS BASED ON SDF_SYMB_FLAGS */

      DECLARE NDX BIT(16);
      DECLARE I BIT(16);
      DECLARE (SDFFLAGS,FLAGS) FIXED;
      DECLARE #FLAGS LITERALLY '13',
         IN_FLAG(#FLAGS-1) FIXED CONSTANT(SDF_EXCLUSIVE_FLAG,SDF_RIGID_FLAG,
            SDF_INIT_FLAG,SDF_REMOTE_FLAG,SDF_LOCK_FLAG,SDF_LATCH_FLAG,
            SDF_ACCESS_FLAG,SDF_CONSTANT_FLAG,SDF_NAME_FLAG,SDF_AUTO_FLAG,
            SDF_TEMPORARY_FLAG,SDF_ASSIGN_PARM_FLAG,SDF_INPUT_PARM_FLAG),
         OUT_FLAG(#FLAGS-1) FIXED CONSTANT(EXCLUSIVE_FLAG,RIGID_FLAG,
            INIT_FLAG,REMOTE_FLAG,LOCK_FLAG,LATCHED_FLAG,
            ACCESS_FLAG,CONSTANT_FLAG,NAME_FLAG,AUTO_FLAG,
            TEMPORARY_FLAG,ASSIGN_PARM,INPUT_PARM);
      SDFFLAGS = SDF_SYMB_FLAGS;
      /*-------------------------------------------------------------*/
      /*----------------- DANNY STRAUSS DR102949 --------------------*/
      /* IF A 16-BIT NAME VARIABLE WAS INITIALIZED TO A NON-REMOTE   */
      /* VARIABLE IN A REMOTELY INCLUDED COMPOOL, IT'S NOW INVALID   */
      SDF_INITIAL_CHECK: PROCEDURE;
         IF (INCL_FLAGS & INCL_REMOTE_FLAG) ^= 0  /* REMOTE COMPOOL */
           /* IF VARIABLE IS REFERENCED BY A NAME VARIABLE */
           THEN IF (SDFFLAGS & SDF_MISC_NAME_FLAG) ^= 0
             THEN IF SYT_TYPE(NDX) ^= TEMPL_NAME /* NOT A STRUC TEMPL */
               THEN IF (SDFFLAGS & SDF_REMOTE_FLAG) = 0 /* NON-REMOTE */
                 THEN  DO; CALL ERROR(CLASS_DI,21);
                        /*OUTPUT = 'DANNY>>> CUR_SYM= ' || CUR_SYMBOL;*/
                       END;
      END SDF_INITIAL_CHECK;
      CALL SDF_INITIAL_CHECK;
      /*-------------------------------------------------------------*/
 IF CONTROL("3") THEN OUTPUT = 'SET_SYT_FLAGS: SDFFLAGS = '||
    HEX(SDFFLAGS, 8)||' INCL_FLAGS = '||HEX(INCL_FLAGS, 2);
      IF ACCESS_COMPOOL THEN FLAGS = READ_ACCESS_FLAG;
      ELSE FLAGS = 0;
      IF (SDFFLAGS & SDF_DENSE_FLAG) ^= 0 THEN
         FLAGS = FLAGS | DENSE_FLAG;
      ELSE FLAGS = FLAGS | ALIGNED_FLAG;
 /*********** FIX FOR DR100579, ROBERT HANDLEY 12/88  *************/
 /* SET THE VARIABLE'S REMOTE FLAG IF THE COMPOOL IS INCLUDED
    REMOTELY. EXCLUDE STRUCTURE TEMPLATE SYMBOL NAMES AND NAME
    VARIABLES.*/
 /*------------------- DANNY STRAUSS DR100579 ------------------------*/
 /* INCLUDED_REMOTE MEANS VARIABLE LIVES REMOTE ONLY BECAUSE          */
 /* IT WAS INCLUDED REMOTE. (IT RESIDES IN #P, NOT IN #R)             */
      IF (INCL_FLAGS & INCL_REMOTE_FLAG) ^= 0 THEN /* REMOTE COMPOOL */
         IF (SYT_CLASS(NDX) ^= TEMPLATE_CLASS) THEN DO;
            /* NOT A NAME VARIABLE & NOT INITIALLY DECLARED REMOTE */
            IF ((SDFFLAGS & SDF_NAME_FLAG) = 0) &
               ((SDFFLAGS & SDF_REMOTE_FLAG) = 0) THEN
               FLAGS = FLAGS | REMOTE_FLAG | INCLUDED_REMOTE;
            /* FOR NAME VARIABLES, SET THAT THEY NOW LIVE REMOTE */
            IF ((SDFFLAGS & SDF_NAME_FLAG) ^= 0) THEN
               FLAGS = FLAGS | INCLUDED_REMOTE;
         END;
 /**************** END OF FIX FOR DR100579  ***********************/
      DO I = 0 TO #FLAGS - 1;
         IF (SDFFLAGS & IN_FLAG(I)) ^= 0 THEN
            FLAGS = FLAGS | OUT_FLAG(I);
      END;
      SYT_FLAGS(NDX) = FLAGS;
      NAME_IMPLIED = ((FLAGS & NAME_FLAG) ^= 0);
      TEMPORARY_IMPLIED = ((FLAGS & TEMPORARY_FLAG) ^= 0);
      IF CONTROL("3") THEN OUTPUT = 'SET_SYT_FLAGS:    FLAGS = ' ||
         HEX(FLAGS, 8);
      RETURN;
   END SET_SYT_FLAGS;

SET_TYPE_AND_LEN:
   PROCEDURE(NDX);
   /* SET SYT_TYPE AND VAR_LENGTH FOR VARIABLES AND FUNCTIONS */

      DECLARE NDX BIT(16);
      DECLARE TYPE BIT(16);
      ARRAY P1_TYPE(17) BIT(8) CONSTANT(0,BIT_TYPE,CHAR_TYPE,MAT_TYPE,/*C13335*/
         VEC_TYPE,SCALAR_TYPE,INT_TYPE,0,0,BIT_TYPE,BIT_TYPE,MAT_TYPE,
         VEC_TYPE,SCALAR_TYPE,INT_TYPE,0,MAJ_STRUC,EVENT_TYPE);
      DECLARE STRUC_NAME CHARACTER;
      SYT_TYPE(NDX), TYPE = P1_TYPE(SDF_SYMB_TYPE);
      IF (TYPE >=MAT_TYPE) & (TYPE<=INT_TYPE) THEN DO;
         IF SDF_SYMB_TYPE > 8 THEN
            SYT_FLAGS(NDX) = SYT_FLAGS(NDX) | DOUBLE_FLAG;
         ELSE SYT_FLAGS(NDX) = SYT_FLAGS(NDX) | SINGLE_FLAG;
      END;
      IF (TYPE = CHAR_TYPE) | (TYPE = MAT_TYPE) THEN
         VAR_LENGTH(NDX) = SDF_SYMB_VAR_LENGTH;
      ELSE IF (TYPE = BIT_TYPE) | (TYPE = VEC_TYPE) THEN
         VAR_LENGTH(NDX) = SDF_SYMB_VAR_LENGTH & "FF";
      ELSE IF (TYPE = MAJ_STRUC) & (SDF_SYMB_VAR_LENGTH ^= 0) THEN DO;
         TEMP_PTR = SDFPKG_LOC_PTR;
         LOCATE_SDF_SYMB#(SDF_SYMB_VAR_LENGTH);
         STRUC_NAME = NEW_STRING(SDFPKG_SYMBNAM);
         LOCATE_SDF_PTR(TEMP_PTR);
         STRUC_PTR = FIND(STRUC_NAME);
         IF STRUC_PTR = 0 THEN DO;
            CALL ERROR(CLASS_DU, 5, SUBSTR(STRUC_NAME,1));
            STRUC_PTR = ENTER(STRUC_NAME, TEMPLATE_CLASS);
            SYT_TYPE(STRUC_PTR) = TEMPL_NAME;
            SYT_FLAGS(STRUC_PTR) = EVIL_FLAG;
            IF BUILDING_TEMPLATE THEN
               SYT_FLAGS(REF_ID_LOC) = SYT_FLAGS(REF_ID_LOC) | EVIL_FLAG;
         END;
         STRUC_DIM = 0;  /* SO NO ARRAY CHECKS IN CHECK_STRUC_CONFLICT */
         CALL CHECK_STRUC_CONFLICTS;
         VAR_LENGTH(NDX) = STRUC_PTR;
         SYT_XREF(STRUC_PTR) = ENTER_XREF(SYT_XREF(STRUC_PTR), XREF_REF);
      END;
      IF CONTROL("3") THEN
         OUTPUT = 'SET_TYPE_AND_LEN: TYPE = ' || TYPE || ', LENGTH = ' ||
            VAR_LENGTH(NDX);
      RETURN;
   END SET_TYPE_AND_LEN;

ENTER_SDF_VAR:
   PROCEDURE(CLASS);
   /* ENTER A VARIABLE OR FUNCTION FROM AN SDF INTO THE SYMBOL TABLE */

      DECLARE CLASS BIT(16);
      DECLARE I BIT(16);
      IF DUPLICATE_NAME(BCD) THEN DO;
         CALL ERROR(CLASS_PM, 1, BCD);
         RETURN;
      END;
      ID_LOC = ENTER(BCD, CLASS);
      IF CONTROL("3") THEN
         OUTPUT = 'ENTER_SDF_VAR: ID_LOC = ' || ID_LOC || ', NAME = ' || BCD ||
            ', CLASS = ' || CLASS;
      CALL SET_SYT_FLAGS(ID_LOC);
      CALL SET_TYPE_AND_LEN(ID_LOC);
      SYT_ADDR(ID_LOC) = SDF_SYMB_ADDR;
      SYT_LOCK#(ID_LOC) = SDF_SYMB_LOCK#;
      IF SDF_SYMB_ARRAY_OFF = 0 THEN SYT_ARRAY(ID_LOC) = 0;
      ELSE IF SYT_TYPE(ID_LOC) = MAJ_STRUC THEN DO;
         I = SDF_SYMB_ARRAY(0);
         IF I < 0 THEN SYT_ARRAY(ID_LOC) = -ID_LOC;
         ELSE IF I = 1 THEN SYT_ARRAY(ID_LOC) = 0;
         ELSE SYT_ARRAY(ID_LOC) = I;
      END;
      ELSE DO;  /* ENTER ARRAY VALUES */
         N_DIM = SDF_SYMB_NDIM;
         DO I = 0 TO N_DIM - 1;
            S_ARRAY(I) = SDF_SYMB_ARRAY(I);
         END;
         IF S_ARRAY(0) < 0 THEN S_ARRAY(0) = -ID_LOC;
         CALL ENTER_DIMS;
         SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | ARRAY_FLAG;
      END;
      IF (SDF_SYMB_FLAGS & SDF_LIT_FLAG) ^= 0 THEN DO;  /* ENTER LITERAL */
         TEMP_PTR = SDFPKG_LOC_PTR;
         LOCATE_SDF_PTR(SDF_SYMB_LIT_PTR);
         IF SYT_TYPE(ID_LOC) = CHAR_TYPE THEN
            CALL SAVE_LITERAL(0,MAKESTRING(SDF_B + 1, SDFPKG_LOC_ADDR + 1));
         /* ARITH. LIT */
         ELSE CALL SAVE_LITERAL(1, SDFPKG_LOC_ADDR,0,1);    /*MOD-DR109083*/
         SYT_PTR(ID_LOC) = -LIT_TOP;
         LOCATE_SDF_PTR(TEMP_PTR);
      END;
      RETURN;
   END ENTER_SDF_VAR;

ENTER_SDF_LABEL:
   PROCEDURE(CLASS);
   /* ENTER A LABEL INTO THE SYMBOL TABLE FROM AN SDF              */
   /* COMPILATION UNIT IS TREATED SEPARATELY IN INCLUDE_SDF PROPER */

      DECLARE CLASS BIT(16);
      ARRAY   P1_TYPE(7) BIT(8)                            /*DR109040 CR13335*/
         CONSTANT(0,PROG_LABEL,PROC_LABEL,0,COMPOOL_LABEL, /*DR109040*/
                  TASK_LABEL,0,0);                         /*DR111350*/
      IF DUPLICATE_NAME(BCD) THEN
      /*DR111350 - COMPOOL CLOSE LABELS CAN BE DUPLICATED */
         IF SDF_SYMB_TYPE ^= 7 THEN /*DR111350*/
            CALL ERROR(CLASS_PL, 2, BCD);
      ID_LOC = ENTER(BCD, CLASS);
      IF CONTROL("3") THEN
         OUTPUT = 'ENTER_SDF_LABEL: ID_LOC = ' || ID_LOC || ', NAME = ' ||
            BCD || ', CLASS = ' || CLASS;
      CALL SET_SYT_FLAGS(ID_LOC);
      SYT_TYPE(ID_LOC) = P1_TYPE(SDF_SYMB_TYPE);
      SYT_ADDR(ID_LOC) = SDF_SYMB_ADDR;
      RETURN;
   END ENTER_SDF_LABEL;

ENTER_SDF_TEMPLATE:
   PROCEDURE;
   /* ENTER A TEMPLATE FROM AN SDF */

      ARRAY   FATHER(MAX_STRUC_LEVEL) BIT(16);       /*CR13335*/
      DECLARE CLASS BIT(16), LEVEL BIT(16);
      IF DUPLICATE_NAME(BCD) THEN
         CALL ERROR(CLASS_PM, 2, SUBSTR(BCD,1));
      REF_ID_LOC = ENTER(BCD, TEMPLATE_CLASS);
      IF CONTROL("3") THEN
         OUTPUT = 'ENTER_SDF_TEMPLATE: ID_LOC = ' || REF_ID_LOC ||
            ', NAME = ' || BCD;
      SYT_TYPE(REF_ID_LOC) = TEMPL_NAME;
      CALL SET_SYT_FLAGS(REF_ID_LOC);
      IF (SDF_SYMB_FLAGS & SDF_MISC_NAME_FLAG) ^= 0 THEN
         SYT_FLAGS(REF_ID_LOC) = SYT_FLAGS(REF_ID_LOC) | MISC_NAME_FLAG;
      STRUC_SIZE = 0;
      BUILDING_TEMPLATE = TRUE;
      LEVEL = 0;
      FATHER(0) = REF_ID_LOC;
      SYT_LINK1(REF_ID_LOC) = REF_ID_LOC + 1;
WALK: DO UNTIL LEVEL < 0;
         LOCATE_SDF_SYMB#(NEXT_SYMBOL);
         CUR_SYMBOL = NEXT_SYMBOL;
         NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
         BCD = NEW_STRING(SDFPKG_SYMBNAM);
         CLASS = SDF_SYMB_CLASS;
         IF CLASS = 4 THEN CALL ENTER_SDF_VAR(TEMPLATE_CLASS);
         ELSE IF CLASS = 5 THEN CALL ENTER_SDF_LABEL(TPL_LAB_CLASS);
         ELSE CALL ENTER_SDF_VAR(TPL_FUNC_CLASS);
         IF SDF_SYMB_LINK1 ^= 0 THEN DO;
            IF SDF_SYMB_LINK2 < 0 THEN SYT_LINK2(ID_LOC) = -FATHER(LEVEL);
            ELSE SYT_LINK2(ID_LOC) = 0; /* TO BE FILLED IN LATER */
            LEVEL = LEVEL + 1;
            FATHER(LEVEL) = ID_LOC;
            SYT_LINK1(ID_LOC) = ID_LOC + 1;
         END;
         ELSE DO;
            SYT_LINK1(ID_LOC) = 0;
            IF SDF_SYMB_LINK2 > 0 THEN SYT_LINK2(ID_LOC) = ID_LOC + 1;
            ELSE DO;
               SYT_LINK2(ID_LOC) = -FATHER(LEVEL);
               DO WHILE SYT_LINK2(FATHER(LEVEL)) < 0;
                  LEVEL = LEVEL - 1;
               END;
               IF LEVEL > 0 THEN DO;
                  SYT_LINK2(FATHER(LEVEL)) = ID_LOC + 1;
                  IF CONTROL("3") THEN
                     OUTPUT = 'ENTER_SDF_TEMPLATE: LINK2(' || FATHER(LEVEL) ||
                        ') = ' || ID_LOC + 1;
               END;
               LEVEL = LEVEL - 1;
            END;
         STRUC_SIZE = STRUC_SIZE + ICQ_TERM#(ID_LOC) * ICQ_ARRAY#(ID_LOC);
         END;
         IF CONTROL("3") THEN
            OUTPUT = 'ENTER_SDF_TEMPLATE: LINK1 = ' || SYT_LINK1(ID_LOC) ||
               ', LINK2 = ' || SYT_LINK2(ID_LOC);
      END WALK;
      BUILDING_TEMPLATE = FALSE;
      SYT_ADDR(REF_ID_LOC) = STRUC_SIZE;
      RETURN;
   END ENTER_SDF_TEMPLATE;

ENTER_SDF_MACRO:
   PROCEDURE;
   /* ENTER A REPLACE MACRO FROM AN SDF */

      DECLARE MACRO_NDX BIT(16), #BYTES BIT(16);
      DECLARE I BIT(16);
      IF DUPLICATE_NAME(BCD) THEN DO;
         CALL ERROR(CLASS_PM, 1, BCD);
         RETURN;
      END;
      MACRO_NDX = ENTER(BCD, REPL_CLASS);
      IF CONTROL("3") THEN
         OUTPUT = 'ENTER_SDF_MACRO: ID_LOC = ' || MACRO_NDX || ', MACRO = ' ||
            BCD;
      TEMP_PTR = SDFPKG_LOC_PTR;
      LOCATE_SDF_PTR(SDF_SYMB_REPL_PTR);
      MACRO_ARG_COUNT = SDF_REPL_ARG_CNT;
      DO I = 1 TO MACRO_ARG_COUNT;
         BCD = NEW_STRING(SDF_REPL_ARG_NAME(I));
         ID_LOC = ENTER(BCD, REPL_ARG_CLASS);
         IF CONTROL("3") THEN
            OUTPUT = 'ENTER_SDF_MACRO: ID_LOC = ' || ID_LOC ||
               ', ARG = ' || BCD;
         SYT_FLAGS(ID_LOC) = INACTIVE_FLAG;
      END;
      VAR_LENGTH(MACRO_NDX) = MACRO_ARG_COUNT;
      START_POINT, SYT_ADDR(MACRO_NDX) = FIRST_FREE;
MOVE_TEXT:
      DO WHILE SDF_REPL_NEXT_PTR ^= 0;
         LOCATE_SDF_PTR(SDF_REPL_NEXT_PTR);
         #BYTES = SDF_REPL_#BYTES;
         DO I= 1 TO #BYTES;
            NEXT_ELEMENT(MACRO_TEXTS);
         END;
         CALL MOVE(#BYTES, SDF_REPL_TEXT_ADDR, ADDR(MACRO_TEXTS(FIRST_FREE)));
         FIRST_FREE = FIRST_FREE + #BYTES;
         END;
      CALL FINISH_MACRO_TEXT;
      EXTENT(MACRO_NDX) = REPLACE_TEXT_PTR;
      LOCATE_SDF_PTR(TEMP_PTR);
      RETURN;
   END ENTER_SDF_MACRO;

ENTER_SDF_THING:
   PROCEDURE;
   /* ENTERS LAST SDF VARIABLE LOCATED INTO THE SYMBOL TABLE BY CALLING THE */
   /* APPROPRIATE ROUTINE                                                   */

      IF CONTROL("3") THEN OUTPUT = 'ENTER_SDF_THING: ENTERED';
      BCD = NEW_STRING(SDFPKG_SYMBNAM);
      DO CASE SDF_SYMB_CLASS;
         ; /* NOT USED */
         CALL ENTER_SDF_VAR(VAR_CLASS); /* SDF VARIABLE CLASS */
         DO; /*SDF LABEL CLASS */
            IF SDF_SYMB_TYPE = 9 THEN CALL ENTER_SDF_MACRO;
            ELSE IF SDF_SYMB_TYPE ^= 8 THEN CALL ENTER_SDF_LABEL(LABEL_CLASS);
         END;
         CALL ENTER_SDF_VAR(FUNC_CLASS); /* SDF FUNCTION CLASS */
         DO; /* SDF TEMPLATE CLASS */
            IF (SDF_SYMB_FLAGS & SDF_TPL_HDR_FLAG) ^= 0 THEN
               CALL ENTER_SDF_TEMPLATE;
            ELSE CALL ERROR(CLASS_XI, 8, BCD);
         END;
         CALL ERROR(CLASS_XI, 8, BCD); /* SDF TEMPLATE LABEL CLASS */
         CALL ERROR(CLASS_XI, 8, BCD); /* SDF TEMPLATE FUNCTION */
      END;
      RETURN;
   END ENTER_SDF_THING;

ENTER_COMSUB_ARGS:
   PROCEDURE;
   /* LOGIC TO ENTER APPROPRIATE STUFF AND THEN ARGUMENTS FOR COMSUBS*/

      DECLARE SAVE_FIRST BIT(16);
      IF CONTROL("3") THEN OUTPUT = 'ENTER_COMSUB_ARGS: ENTERED';

      /* PASS OVER PARAMETERS AND ENTER TEMPLATES, IF ANY */
      SAVE_FIRST = NEXT_SYMBOL;
      DO UNTIL CUR_SYMBOL = LAST_COMSUB_SYMB;
         CUR_SYMBOL = NEXT_SYMBOL;
         LOCATE_SDF_SYMB#(CUR_SYMBOL);
         NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
         IF (SDF_SYMB_FLAGS & SDF_PARM_FLAGS) = 0 THEN DO;
            BCD = NEW_STRING(SDFPKG_SYMBNAM);
            IF BYTE(BCD) = BYTE(' ') THEN
               CALL ENTER_SDF_TEMPLATE;
         END;
      END;

      /* NOW ENTER PARAMETERS */
      NEXT_SYMBOL = SAVE_FIRST;
      SYT_PTR(BLOCK_SYTREF(NEST)) = NDECSY + 1; /* POINT TO FIRST ARG */
      DO UNTIL CUR_SYMBOL = LAST_COMSUB_SYMB;
         CUR_SYMBOL = NEXT_SYMBOL;
         LOCATE_SDF_SYMB#(CUR_SYMBOL);
         NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
         IF (SDF_SYMB_FLAGS & SDF_PARM_FLAGS) = 0 THEN ESCAPE;
         CALL ENTER_SDF_THING;
      END;
      RETURN;
   END ENTER_COMSUB_ARGS;

ENTER_COMPOOL_VARS:
   PROCEDURE;
   /* ENTER VARIABLES FROM A COMPOOL SDF  */
      DECLARE TEMP BIT(8);

      IF CONTROL("3") THEN OUTPUT = 'ENTER_COMPOOL_VARS: ENTERED';
      ACCESS_COMPOOL = ((SYT_FLAGS(BLOCK_SYTREF(NEST)) & ACCESS_FLAG) ^= 0);
      PROCMARK = 1;
      /* AUGMENT SDFPKG PAGING AREA IF NECESSARY/POSSIBLE */
      TEMP=RECORD_ALLOC(SYM_TAB)-RECORD_USED(SYM_TAB);
      IF TEMP <= #BLK_SYMBS THEN DO;
         TEMP = RECORD_USED(SYM_TAB) + #BLK_SYMBS;
         DO WHILE RECORD_ALLOC(SYM_TAB)<=TEMP;
            NEEDMORE_SPACE(SYM_TAB);
         END;
      END;
      SDFPKG_NPAGES=(FREELIMIT-FREESTRING_MIN-FREEPOINT-32*#BLK_SYMBS)/1680;
      SDFPKG_NPAGES = MIN(SDFPKG_NPAGES, #SDF_PAGES - 3);
      SDFPKG_NPAGES = MIN(SDFPKG_NPAGES, SDFPKG_PAGES_LEFT);
      IF SDFPKG_NPAGES > 0 THEN DO;
         RECORD_CONSTANT(PGING,SDFPKG_NPAGES,UNMOVEABLE);
         SDFPKG_APGAREA=ADDR(PGING(0).PAGEADDR(0));
         SDFPKG_AFCBAREA, SDFPKG_NBYTES = 0;
         CALL_SDFPKG(2);  /* AUGMENT PAGING AREA */
      END;
      /*ENTER EVERYTHING */
      DO WHILE NEXT_SYMBOL ^= 0;
         LOCATE_SDF_SYMB#(NEXT_SYMBOL);
    /*CUR_SYMBOL = NEXT_SYMBOL;  DANNY STRAUSS*/
         NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
         IF SDF_SYMB_CLASS = SDF_VAR_CLASS THEN  /* A VARIABLE OR CONSTANT */
            IF (SDF_SYMB_FLAGS & SDF_LIT_FLAG) = 0 THEN /* ITS A VARIABLE */
                  CSECT_LENGTH((SDF_SYMB_FLAGS&SDF_REMOTE_FLAG)^=0) =
                     MAX(CSECT_LENGTH((SDF_SYMB_FLAGS&SDF_REMOTE_FLAG)^=0),
                     (SDF_SYMB_ADDR+SDF_SYMB_EXTENT));
         /* INCLUDE_OK SETS C TO FIRST TOKEN AFTER INCLUDE OPTIONS */
         IF C ^= ':' THEN CALL ENTER_SDF_THING;
      END;
      /* INCLUDE_OK SETS C TO FIRST TOKEN AFTER INCLUDE OPTIONS */
      IF C = ':' THEN DO;  /* ENTER FROM A LIST */
         SYT_FLAGS(BLOCK_SYTREF(NEST)) = SYT_FLAGS(BLOCK_SYTREF(NEST))
            | SDF_INCL_LIST;  /* FLAG AS PARTIAL INCLUDE */
         D_CONTINUATION_OK = TRUE;
         C = D_TOKEN;
LIST:    DO WHILE C ^= '';
            IF C = ',' THEN DO;
               C = D_TOKEN;
               REPEAT LIST;
            END;
            IF C = ';' THEN ESCAPE LIST;
            IF C = 'STRUCTURE' THEN
               C = X1 || D_TOKEN;
            LOCATE_SDF_SYMBNAME(C);
            IF SDFPKG_CRETURN = 0 THEN DO;
               NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
               CALL ENTER_SDF_THING;
            END;
            ELSE IF BYTE(C) = BYTE(' ') THEN
               CALL ERROR(CLASS_XI, 6, SUBSTR(C,1));
            ELSE CALL ERROR(CLASS_XI, 7, C);
            C = D_TOKEN;
         END LIST;
         D_CONTINUATION_OK = FALSE;
      END;
      ACCESS_COMPOOL = FALSE;
      RETURN;
   END ENTER_COMPOOL_VARS;

SDF_FOUND:
   PROCEDURE BIT(1);
   /* ROUTINE THAT TRIES TO FIND APPLICABLE SDF FOR AN INCLUDE */

      DECLARE COMPILER CHARACTER,
         DDBAD(1) BIT(1) INITIAL(FALSE,FALSE),
         MISC_VAL(1) BIT(16) CONSTANT(8,12),
         SOURCE_FLAG(1) BIT(8) CONSTANT("80","40"),
         OLD_SDF BIT(1), I BIT(16);
      DECLARE REASON(1) CHARACTER CONSTANT(' TOO OLD', ' NOT FOUND');

      /* ALLOCATE SPACE FOR SDFPKG */
      COREWORD(ADDR(COMMTABL_BYTE)),
         COREWORD(ADDR(COMMTABL_HALFWORD)),
         COREWORD(ADDR(COMMTABL_FULLWORD)) = ADDR(COMMTABL);
      COMMTABL_ADDR = ADDR(COMMTABL);
      IF RECORD_ALLOC(INIT_APGAREA) = 0 THEN DO;
         SDFPKG_NPAGES = 3;  /* PAGING AREA SIZE */
         RECORD_CONSTANT(INIT_APGAREA,0,UNMOVEABLE);
        RECORD_USED(INIT_APGAREA) = RECORD_ALLOC(INIT_APGAREA);
         SDFPKG_NBYTES = 512;  /* SIZE OF INITIAL FCB AREA */
         RECORD_CONSTANT(INIT_AFCBAREA,0,UNMOVEABLE);
         RECORD_USED(INIT_AFCBAREA) = RECORD_ALLOC(INIT_AFCBAREA);
      END;

      /* INITIALIZE */
      COMPILER = SUBSTR(STRING(MONITOR(23)),0,4);
      SDF_NAME = '##' || SUBSTR(DESCORE(UNIT),2,6);
      OLD_SDF = FALSE;

      /* TRY HALSDF, THEN OUTPUT5.  AN SDF IS GOOD IF:                       */
      /*    THE DDNAME HAS BEEN DEFINED                                      */
      /*    THE SDF EXISTS                                                   */
      /*    THE SDF WAS MADE BY A COMPILATION FOR THE APPROPRIATE OBJECT     */
      /*       MACHINE, AND                                                  */
      /*    THE SDF WAS CREATED BY A PHASE3 OF VERSION >= INCLUDABLE_VERSION#*/
      DO I = 0 TO 1;
         IF DDBAD(I) THEN REPEAT;
         SDFPKG_NPAGES = 3;
         SDFPKG_APGAREA = ADDR(INIT_APGAREA(0).AREAPG(0));
         SDFPKG_NBYTES = 512;
         SDFPKG_AFCBAREA = ADDR(INIT_AFCBAREA(0).AREAFCB(0));
         SDFPKG_MISC = MISC_VAL(I);
         CALL MONITOR(22, 0, COMMTABL_ADDR);
         IF SDFPKG_CRETURN ^= 0 THEN DDBAD(I) = TRUE;
         ELSE DO;  /* DDNAME EXISTS */
            SDF_OPEN = TRUE;
            SDFPKG_PAGES_LEFT = SDFPKG_NPAGES;
            CALL MOVE(8, SDF_NAME, SDFPKG_SDFNAM_ADDR);
            CALL_SDFPKG(4);
            IF SDFPKG_CRETURN = 12 THEN DO; /* INSUFFICIENT FCB AREA */
               SDFPKG_NPAGES, SDFPKG_APGAREA = 0;
               /* SDFPKG SETS SDFPKG_NBYTES TO AMOUNT NEEDED */
      RECORD_CONSTANT(FORFCB,SHR(SDFPKG_NBYTES+511,9),UNMOVEABLE);
      SDFPKG_AFCBAREA=ADDR(FORFCB(0).FCBADDR(0));
               CALL_SDFPKG(2); /* TELL SDFPKG ABOUT EXTRA SPACE */
               CALL_SDFPKG(4); /* RE-TRY SELECT */
            END;
            REV = SDFPKG_BLKNO;
            CAT = SDFPKG_SYMBNO;
            IF SDFPKG_CRETURN = 0 THEN DO;  /* SDF FOUND */
               LOCATE_SDF_ROOT;
               IF COMPILER = SDF_ROOT_COMPILER THEN DO; /* CORRECT OBJECT */
                  LOCATE_SDF_PTR(0);
                  SDF_VERSION#=SDF_H;
                  IF SDF_H >= INCLUDABLE_VERSION# THEN DO; /* GOOD SDF */
                     INCL_FLAGS = INCL_FLAGS | SOURCE_FLAG(I);
                     REVSTR = 'RVL ' || STRING("01000000" | ADDR(REV)) ||
                              ' CATENATION NUMBER ' || CAT;
                     RETURN TRUE;
                  END;
                  ELSE OLD_SDF = TRUE;
               END;
            END;
            TERMINATE_SDFPKG;
         END;  /* OF DDNAME OK */
      END;  /* OF DO I = */

      /* IF WE GET HERE, WE HAVE FAILED */
      IF RECORD_ALLOC(FORFCB) >0 THEN
         RECORD_FREE(FORFCB);
      IF OLD_SDF THEN I = 0;
      ELSE I = 1;
      COMPILER = COMPILER || ' SDF ' || SDF_NAME;
         IF (INCL_FLAGS & INCL_TEMPLATE_FLAG) ^=0 THEN
      OUTPUT = X8 || STARS || 'INCLUDED FROM TEMPLATE: ' || COMPILER ||
            REASON(I);
      ELSE CALL ERROR(CLASS_XI, I+9, COMPILER);
      RETURN FALSE;
   END SDF_FOUND;

   /* THIS IS THE START OF INCLUDE_SDF PROPER */

   /* CHECK FOR LEGAL INCLUDE */
   IF NEST > 0 THEN DO;
      CALL ERROR(CLASS_PE, 1);
      RETURN TRUE;  /* DON'T TRY THE TEMPLATE */
   END;
   ELSE IF BLOCK_MODE > 0 THEN DO;
      CALL ERROR(CLASS_PE, 2);
      RETURN TRUE;
   END;

   /* CHECK TO SEE IF AN SDF EXISTS */
   IF ^SDF_FOUND THEN RETURN FALSE;

   /* ENTER THE COMPILATION UNIT INTO THE SYMBOL TABLE */
   LOCATE_SDF_ROOT;
   SDF_ROOT_FLAGS = SDF_H(0); /*CR11120-#DFLAG LOOK AT ROOT FLAGS*/
   LAST_COMSUB_SYMB = SDF_ROOT_COMSUB_END;
   UNIT_SYMB# = SDF_ROOT_UNIT_SYMB#;
   #SDF_PAGES = SDF_ROOT_LAST_PAGE + 1;
   LOCATE_SDF_BLOCK#(SDF_ROOT_UNIT_BLK#);
   IF SDFPKG_BLKNAM ^= UNIT THEN DO;
      UNIT = NEW_STRING(SDFPKG_BLKNAM);
      /* ERROR CALL DELETED AT IBM REQUEST*/
   END;
   IF DUPLICATE_NAME(UNIT) THEN
      CALL ERROR(CLASS_PL, 2, UNIT); /* BUT CONTINUE ANYWAY */
   #BLK_SYMBS = SDF_BLK_LAST_SYMB# - SDF_BLK_FIRST_SYMB# + 1;
   ID_LOC = ENTER(UNIT, LABEL_CLASS);
   BLK_TYPE = SDF_BLK_CATEGORY;
   FLAGS = EXTERNAL_FLAG | DEFINED_LABEL | SDF_INCL_FLAG;
   IF (INCL_FLAGS & INCL_REMOTE_FLAG) ^= 0 THEN DO;
      IF BLK_TYPE = 4 /* COMPOOL */ THEN
         FLAGS = FLAGS | REMOTE_FLAG;
      ELSE CALL ERROR(CLASS_XI, 5);
      TPL_REMOTE = FALSE;
   END;
   DO I = 0 TO #BLK_FLAGS;
      IF (SDF_BLK_FLAGS & IN_BLK_FLAG(I)) ^= 0 THEN
         FLAGS = FLAGS | OUT_BLK_FLAG(I);
   END;
   SYT_FLAGS(ID_LOC) = FLAGS;

   /* DO BLOCK "ENTRY" */
   NEST = 1;
   SCOPE#_STACK(NEST) = SCOPE#;
   SYT_SCOPE(ID_LOC), SCOPE#, MAX_SCOPE# = MAX_SCOPE# + 1;
   NEXT_ELEMENT(CSECT_LENGTHS);
   PROCMARK_STACK(NEST) = PROCMARK;
   PROCMARK, REGULAR_PROCMARK = NDECSY + 1;
   BLOCK_SYTREF(NEST) = ID_LOC;
   SYT_PTR(ID_LOC) = PROCMARK;
   CALL ENTER_LAYOUT(ID_LOC);
   SYT_LOCK#(ID_LOC) = SDF_BLK_VERSION#;

   /* ENTER SYMBOLS BASED ON BLOCK TYPE */
   LOCATE_SDF_SYMB#(UNIT_SYMB#);
   NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
   DO CASE BLK_TYPE;
      ; /* UNDEFINED */
      DO;  /* PROGRAM */
         BLOCK_MODE(NEST) = PROG_MODE;
         SYT_TYPE(ID_LOC) = PROG_LABEL;
         SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | LATCHED_FLAG;
      END;
      DO; /* PROCEDURE */
/*- CR11120 ----------------- #DFLAG ------------------------------*/
/* IF DATA_REMOTE FLAG SET IN SDF, THEN SET THE COMSUB'S REMOTE    */
/* FLAG SO THAT OBJECT GENERATOR KNOWS TO SET BIT IN ESD CARD FOR  */
/* AUTOMATED PRELINKER PLACEMENT IN THE REMOTE #D CSECT.           */
         IF ((SDF_ROOT_FLAGS & "0004") ^= 0) THEN
            SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | REMOTE_FLAG;
/*-----------------------------------------------------------------*/
         BLOCK_MODE(NEST) = PROC_MODE;
         SYT_TYPE(ID_LOC) = PROC_LABEL;
         IF LAST_COMSUB_SYMB ^= UNIT_SYMB# THEN
            CALL ENTER_COMSUB_ARGS;
      END;
      DO;  /* FUNCTION */
/*- CR11120 ----------------- #DFLAG ------------------------------*/
/* IF DATA_REMOTE FLAG SET IN SDF, THEN SET THE COMSUB'S REMOTE    */
/* FLAG SO THAT OBJECT GENERATOR KNOWS TO SET BIT IN ESD CARD FOR  */
/* AUTOMATED PRELINKER PLACEMENT IN THE REMOTE #D CSECT.           */
         IF ((SDF_ROOT_FLAGS & "0004") ^= 0) THEN
            SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | REMOTE_FLAG;
/*-----------------------------------------------------------------*/
         BLOCK_MODE(NEST) = FUNC_MODE;
         SYT_CLASS(ID_LOC) = FUNC_CLASS;
         CALL SET_TYPE_AND_LEN(ID_LOC);
         IF LAST_COMSUB_SYMB ^= UNIT_SYMB# THEN
            CALL ENTER_COMSUB_ARGS;
      END;
      DO;  /* COMPOOL */
         BLOCK_MODE(NEST) = CMPL_MODE;
         SYT_TYPE(ID_LOC) = COMPOOL_LABEL;
         CSECT_LENGTHS(SCOPE#).PRIMARY = PRIMARY_LENGTH;
         CSECT_LENGTHS(SCOPE#).REMOTE = REMOTE_LENGTH;
         CSECT_LENGTH(0),CSECT_LENGTH(1) = 0;
         CALL ENTER_COMPOOL_VARS;
         CSECT_LENGTHS(SCOPE#).PRIMARY = PRIMARY_LENGTH;
         CSECT_LENGTHS(SCOPE#).REMOTE = REMOTE_LENGTH;
      END;
      ; ; /* TASK, UPDATE */
   END;  /* OF DO CASE BLK_TYPE */

   /* PERFORM BLOCK "CLOSING" */
   SYT_FLAGS(NDECSY) = SYT_FLAGS(NDECSY) | ENDSCOPE_FLAG;
   IF REGULAR_PROCMARK > NDECSY THEN
      SYT_PTR(BLOCK_SYTREF(NEST)) = 0;  /* NO LOCAL SYMBOLS */
   ELSE DO I = 0 TO NDECSY - REGULAR_PROCMARK;
      J = NDECSY - I;
      IF (SYT_FLAGS(J) & INACTIVE_FLAG) ^= 0 THEN REPEAT;
      CLOSE_BCD = SYT_NAME(J);
      CALL DISCONNECT(J);
   END;
   SYT_ARRAY(BLOCK_SYTREF(NEST)) = "E000";
   PROCMARK, REGULAR_PROCMARK = PROCMARK_STACK(NEST);
   SCOPE# = SCOPE#_STACK(NEST);
   NEST = 0;

   /* CLEAN UP */
   DO I = 0 TO FACTOR_LIM;  /* DON'T LEAVE TRACKS */
      TYPE(I) = 0;
   END;
   NAME_IMPLIED, TEMPORARY_IMPLIED = FALSE;
   MACRO_ARG_COUNT, STRUC_PTR, STRUC_DIM, STRUC_SIZE = 0;
   ID_LOC, REF_ID_LOC = 0;
   INCLUDE_STMT = STMT_NUM;                          /*DR109074*/
   STMT_NUM = STMT_NUM + 1;  /* TREAT EACH INCLUDE AS ONE STMT */
   OUTPUT = X8 || STARS || 'INCLUDED FROM SDF ' || SDF_NAME || X1 || STARS;
   OUTPUT = X8 || STARS || REVSTR || X1 || STARS;
   OUTPUT = X1;
   TERMINATE_SDFPKG;
   IF RECORD_ALLOC(FORFCB) > 0 THEN
      RECORD_FREE(FORFCB);
   IF RECORD_ALLOC(PGING) > 0 THEN
      RECORD_FREE(PGING);
   IF SIMULATING THEN
      CALL MAKE_INCL_CELL(SDF_NAME, INCL_FLAGS,
         SHL(REV,16) | CAT);
   RETURN TRUE;
END INCLUDE_SDF /* $S */ ; /* $S */

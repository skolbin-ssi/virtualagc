{
  /*
   * File:      patch0.c
   * For:       SCANxSCANuFINDSuENDuOF.c
   * Notes:     1. Page references are from IBM "ESA/390 Principles of
   *               Operation", SA22-7201-08, Ninth Edition, June 2003.
   *            2. Labels are of the form p%d_%d, where the 1st number
   *               indicates the leading patch number of the block, and
   *               the 2nd is the byte offset of the instruction within
   *               within the block.
   *            3. Known-problematic translations are marked with the
   *               string  "* * * F I X M E * * *" (without spaces).
   * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
   *                            Note that there were 3 bugs in XCOM-I --guess
   *                            revealed in this patch.  I've fixed the bugs, but
   *                            herein they were repaired manually.  Moreover,
   *                            due to the unusual nature of this patch, other
   *                            manual repairs were made pre-p0_0 and in p0_60.
   */

GR[12] = 60;  // Address of end of the procedure's code.

p0_0: ;
  // (0)       CALL INLINE ("58", 3, 0,TEXT); /*LOAD STRING DESCRIPTOR */                
  address360B = (mTEXT) & 0xFFFFFF;
  // Type RX, p. 7-7:		L	3,mTEXT(0,0)
  detailedInlineBefore(0, "L	3,mTEXT(0,0)");
  GR[3] = COREWORD(address360B);
  detailedInlineAfter();

p0_4: ;
  // (1)       CALL INLINE ("1B", 2, 2);      /* CLEAR REG. 2 */                         
  // Type RR, p. 7-127:		SR	2,2
  detailedInlineBefore(1, "SR	2,2");
  scratch = (int64_t) GR[2] - (int64_t) GR[2];
  setCC();
  GR[2] = (int32_t) scratch;
  detailedInlineAfter();

p0_6: ;
  // (2)       CALL INLINE ("19", 3, 2);      /* CHECK FOR TEXT = NULL STRING */         
  // Type RR, p. 7-35:		CR	3,2
  detailedInlineBefore(2, "CR	3,2");
  scratch = (int64_t) GR[3] - (int64_t) GR[2];
  setCC();
  detailedInlineAfter();

  p0_8: ;
    // (3)       CALL INLINE("07", 8, 12);          /* RETURN FALSE IF TEXT IS NULL */
    address360B = GR[12] + 0;
    // Type RR, p. 7-17:          BCR     8,12
    detailedInlineBefore(3, "BCR  8,12");
    mask360 = 8;
    if ((CC == 0 && (mask360 & 8) != 0) || (CC == 1 && (mask360 & 4) != 0) ||
        (CC == 2 && (mask360 & 2) != 0) || (CC == 3 && (mask360 & 1) != 0))
      switch (address360B) {
        case 0: goto p0_0;
        case 4: goto p0_4;
        case 6: goto p0_6;
        case 8: goto p0_8;
        case 10: goto p0_10;
        case 14: goto p0_14;
        case 18: goto p0_18;
        case 22: goto p0_22;
        case 26: goto p0_26;
        case 30: goto p0_30;
        case 32: goto p0_32;
        case 36: goto p0_36;
        case 38: goto p0_38;
        case 42: goto p0_42;
        case 44: goto p0_44;
        case 46: goto p0_46;
        case 50: goto p0_50;
        case 52: goto p0_52;
        case 56: goto p0_56;
        case 60: goto p0_60;
        default: abend("Branch address must be an instruction offset within this block");
      }
    detailedInlineAfter();

p0_10: ;
  // (4)       CALL INLINE ("8D", 2, 0,0,8);  /*  SHIFT LENGTH FIELD TO REG. 2 */        
  // Type RS, p. 7-119:		SLDL	2,0,8(0)
  detailedInlineBefore(4, "SLDL	2,0,8(0)");
  scratch = (((int64_t) GR[2]) << 32) | GR[3];
  scratch = scratch << (((8) & 0xFFFFFF) & 0x3F);
  GR[2] = scratch >> 32;
  GR[3] = scratch & 0xFFFFFFFF;
  detailedInlineAfter();

p0_14: ;
  // (5)       CALL INLINE ("88", 3, 0,0,8);  /* RESTORE STRING ADDRESS  */              
  // Type RS, p. 7-121:		SRL	3,0,8(0)
  detailedInlineBefore(5, "SRL	3,0,8(0)");
  scratch = (8) & 0x3f;
  if (scratch < 32)
    GR[3] = GR[3] >> scratch;
  else
    GR[3] = 0;
  detailedInlineAfter();

p0_18: ;
  // (6)       CALL INLINE ("58", 1, 0,TABLE);/* LOAD BASE ADDRESS OF TRANSuTABLE */
  address360B = (mSCANxSCANuFINDSuENDuOFxTABLE) & 0xFFFFFF;
  // Type RX, p. 7-7:		L	1,mSCANxSCANuFINDSuENDuOFxTABLE(0,0)
  detailedInlineBefore(6, "L	1,mSCANxSCANuFINDSuENDuOFxTABLE(0,0)");
  GR[1] = COREWORD(address360B);
  detailedInlineAfter();

p0_22: ;
  // (7)       CALL INLINE ("41", 12, 0,TRT); /* LOAD ADDRESS OF TRT INSTRUCTION */      
  address360B = (mSCANxSCANuFINDSuENDuOFxTRT) & 0xFFFFFF;
  // Type RX, p. 7-78:		LA	12,mSCANxSCANuFINDSuENDuOFxTRT(0,0)
  detailedInlineBefore(7, "LA	12,mSCANxSCANuFINDSuENDuOFxTRT(0,0)");
  GR[12] = address360B & 0xFFFFFF;
  detailedInlineAfter();

p0_26: ;
  // (8)       CALL INLINE ("44", 2, 0,12,0); /* EXECUTE TRT INSTRUCTION */              
  address360B = (GR[12] + 0) & 0xFFFFFF;
  // Type RX, p. 7-74:		EX	2,0(0,12)
  detailedInlineBefore(8, "EX	2,0(0,12)");
  // Unsupported opcode EX
  trt(GR[3], GR[1], GR[2]);

p0_30: ;
  // (9)       CALL INLINE ("05",  12, 0);    /* LOAD BRANCH REGISTER  */                
  // Type RR, p. 7-14:		BALR	12,0
  detailedInlineBefore(9, "BALR	12,0");
  GR[12] = 32;
  detailedInlineAfter();

p0_32: ;
  // (10)       CALL INLINE ("47", 7, 0,12,18);/*  BRANCH ON CC~=0  */                    
  address360B = (GR[12] + 18) & 0xFFFFFF;
  // Type RX, p. 7-17:		BC	7,18(0,12)
  detailedInlineBefore(10, "BC	7,18(0,12)");
  mask360 = 7;
  if ((CC == 0 && (mask360 & 8) != 0) || (CC == 1 && (mask360 & 4) != 0) || 
      (CC == 2 && (mask360 & 2) != 0) || (CC == 3 && (mask360 & 1) != 0))
    switch (address360B) {
      case 0: goto p0_0;
      case 4: goto p0_4;
      case 6: goto p0_6;
      case 8: goto p0_8;
      case 10: goto p0_10;
      case 14: goto p0_14;
      case 18: goto p0_18;
      case 22: goto p0_22;
      case 26: goto p0_26;
      case 30: goto p0_30;
      case 32: goto p0_32;
      case 36: goto p0_36;
      case 38: goto p0_38;
      case 42: goto p0_42;
      case 44: goto p0_44;
      case 46: goto p0_46;
      case 50: goto p0_50;
      case 52: goto p0_52;
      case 56: goto p0_56;
      case 60: goto p0_60;
      default: abend("Branch address must be an instruction offset within this block");
    }
  detailedInlineAfter();

p0_36: ;
  // (11)       CALL INLINE ("18", 1, 2);      /* LOAD REG. 1 WITH LENGTH(\) - 1 */       
  // Type RR, p. 7-77:		LR	1,2
  detailedInlineBefore(11, "LR	1,2");
  GR[1] = GR[2];
  detailedInlineAfter();

p0_38: ;
  // (12)       CALL INLINE ("41", 0, 0,0,1);  /* LOAD REG. 0 WITH 1  */                  
  address360B = (1) & 0xFFFFFF;
  // Type RX, p. 7-78:		LA	0,1(0,0)
  detailedInlineBefore(12, "LA	0,1(0,0)");
  GR[0] = address360B & 0xFFFFFF;
  detailedInlineAfter();

p0_42: ;
  // (13)       CALL INLINE ("1A", 1, 0);      /* ADD TO OBTAIN IDENTIFIER LNGTH*/        
  // Type RR, p. 7-12:		AR	1,0
  detailedInlineBefore(13, "AR	1,0");
  scratch = (int64_t) GR[1] + (int64_t) GR[0];
  setCC();
  detailedInlineAfter();

p0_44: ;
  // (14)       CALL INLINE ("1B", 3, 3);      /* PUT 0 INTO RETURN REGISTER */           
  // Type RR, p. 7-127:		SR	3,3
  detailedInlineBefore(14, "SR	3,3");
  scratch = (int64_t) GR[3] - (int64_t) GR[3];
  setCC();
  GR[3] = (int32_t) scratch;
  detailedInlineAfter();

p0_46: ;
  // (15)       CALL INLINE ("47", 15, 0,12,24); /* BRANCH AROUND NEXT TWO INSTR*/        
  address360B = (GR[12] + 24) & 0xFFFFFF;
  // Type RX, p. 7-17:		BC	15,24(0,12)
  detailedInlineBefore(15, "BC	15,24(0,12)");
  mask360 = 15;
  if ((CC == 0 && (mask360 & 8) != 0) || (CC == 1 && (mask360 & 4) != 0) || 
      (CC == 2 && (mask360 & 2) != 0) || (CC == 3 && (mask360 & 1) != 0))
    switch (address360B) {
      case 0: goto p0_0;
      case 4: goto p0_4;
      case 6: goto p0_6;
      case 8: goto p0_8;
      case 10: goto p0_10;
      case 14: goto p0_14;
      case 18: goto p0_18;
      case 22: goto p0_22;
      case 26: goto p0_26;
      case 30: goto p0_30;
      case 32: goto p0_32;
      case 36: goto p0_36;
      case 38: goto p0_38;
      case 42: goto p0_42;
      case 44: goto p0_44;
      case 46: goto p0_46;
      case 50: goto p0_50;
      case 52: goto p0_52;
      case 56: goto p0_56;
      case 60: goto p0_60;
      default: abend("Branch address must be an instruction offset within this block");
    }
  detailedInlineAfter();

p0_50: ;
  // (16)       CALL INLINE ("1B", 1, 3);      /* SUBTRACT TO OBTAIN IDENTIFIER LENGTH */ 
  // Type RR, p. 7-127:		SR	1,3
  detailedInlineBefore(16, "SR	1,3");
  scratch = (int64_t) GR[1] - (int64_t) GR[3];
  setCC();
  GR[1] = (int32_t) scratch;
  detailedInlineAfter();

p0_52: ;
  // (17)       CALL INLINE ("41", 3, 0,0,1);  /* LOAD 1 INTO RETURN REGISTER */          
  address360B = (1) & 0xFFFFFF;
  // Type RX, p. 7-78:		LA	3,1(0,0)
  detailedInlineBefore(17, "LA	3,1(0,0)");
  GR[3] = address360B & 0xFFFFFF;
  detailedInlineAfter();

p0_56: ;
  // (18)       CALL INLINE ("50", 1, 0,CP);   /* STORE IDENTIFIER LENGTH */              
  address360B = (mCP) & 0xFFFFFF;
  // Type RX, p. 7-122:		ST	1,mCP(0,0)
  detailedInlineBefore(18, "ST	1,mCP(0,0)");
  COREWORD2(address360B, GR[1]);
  detailedInlineAfter();

p0_60: ;
  descriptor_t *d = fixedToBit(1,GR[3]);
  RETURN(d);
}
